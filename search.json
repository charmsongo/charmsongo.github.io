[{"title":"本机自定义域名映射IP","url":"/2018/11/07/本机自定义域名映射IP/","content":"\n# wins和linux设置\n其实设置很简单，修改 hosts 文件就可以了，下面详细介绍\n## 1.wins修改hosts文件\n路径如下\n```javascript\nC:\\Windows\\System32\\drivers\\etc\\hosts\n```\n打开文件在最后添加如下内容，保存即可即时生效\n```javascript\n192.168.2.1 charmsongo.com\n```\n最可能遇到的问题就是修改后保存问题了，可以参考 [链接](https://www.jb51.net/diannaojichu/133538.html)\n\n## 2.linux修改hosts文件\n路径如下\n```javascript\n/etc/hosts\n```\n使用命令「vi /etc/hosts」,同样在最后添加如下内容,然后保存即可\n```javascript\n192.168.2.1 charmsongo.com\n```\n## 3.访问方式\n访问方式的改变就更简单了，把原来 URL 中的 IP 换成改的域名即可，这里以wins上为例，如下\n```java\n#修改前url\nhttps://192.168.2.1\n\n#修改后url\nhttps://charmsongo.com/\n```\n\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n"},{"title":"java中文件如何加密压缩?","url":"/2018/10/27/java中文件如何加密压缩/","content":"\n# 文件加密压缩\n在现如今已经可以实现大部分功能的互联网需求中，安全成为了需要的非必需品，工作需求中会遇到对导出的 excel 报表 做加密压缩的问题，今天有时间总结一下，我这里简单列举功能代码，连带其它代码文末会一并给出。\n## 1.单个文件加密压缩\n单个文件加密方法，需传输 3 个参数：被压缩源文件，压缩目标文件和加密密钥，如下\n```javascript\n\t/**\n\t * @Title: encrypt_zip \n     * @Description:将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param src_file 待压缩文件路径\n\t * @param dst_file zip路径+文件名 \n\t * @param encode 加密密码  \n\t * @return \n\t */\n\tpublic static void encrypt_zip(String src_file, String dst_file, String encode) {\n\t\tFile file = new File(src_file);\n\n\t\tZipParameters parameters = new ZipParameters();\n\t\tparameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\tparameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); // 压缩级别\n\n\t\tparameters.setEncryptFiles(true);\n\t\tparameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\tparameters.setPassword(encode.toCharArray());//设置密码\n\n\t\ttry {\n\t\t\tZipFile zipFile = new ZipFile(dst_file);\n\t\t\tzipFile.setFileNameCharset(\"gbk\");\n\t\t\tzipFile.addFile(file, parameters);\n\n\t\t} catch (ZipException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n```\n## 2.多文件加密压缩\n\t\n多文件加密压缩和单文件类似，但是，这个方法包含上面的方法，甚至功能上可以替换上面方法，具体看下 code\n\n\n```javascript\n\t/**\n\t * @Title: zipFilesAndEncrypt \n     * @Description: 将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param srcFileName 待压缩文件路径 或 文件夹路径\n\t * @param zipFileName zip路径+文件名 \n\t * @param password 加密密码  \n\t * @return \n\t */\n    public static void zipFilesAndEncrypt(String srcFileName,String zipFileName,String password){  \n    \t\n\t    if(StrTool.is_empty(srcFileName) || StrTool.is_empty(zipFileName)){  \n\t    \tSystem.out.println(\"请求的压缩路径或者文件名有误\");\n\t    \treturn;\n\t    }  \n\t    try {  \n\t\t    ZipParameters parameters = new ZipParameters();  \n\t\t    parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\t    parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL);//压缩级别\n\t\t    if(!StrTool.is_empty(password)){  \n\t\t    \tparameters.setEncryptFiles(true);     \n\t\t\t    parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\t\t    parameters.setPassword(password);  \n\t\t    }  \n\t\t    \n\t\t    ArrayList<File> filesToAdd=getFiles(srcFileName);\n\t\t    \n\t\t    ZipFile zipFile = new ZipFile(zipFileName); \n\t\t    zipFile.setFileNameCharset(\"gbk\");\n\t\t    zipFile.addFiles(filesToAdd, parameters); \n\t    } catch (ZipException e) {  \n\t    \tSystem.out.println(\"文件压缩出错\");\n\t    \te.printStackTrace();\n\t    } \n\t}\n    \n    //通过路径获取压缩文件集合\n    private static ArrayList<File> getFiles(String srcFileName){\n    \tArrayList<File> filesToAdd = new ArrayList<File>();\n\t    File file=new File(srcFileName);\n\t    File[] files = new File[0]; \n\t    if(file.isDirectory()){\n\t    \tfiles = file.listFiles();\n\t    \tfor(int i=0;i<files.length;i++){\n\t    \t\tif(files[i].getName().endsWith(\".xls\")){//xls结尾的excel添加压缩集合\n\t    \t\t\tfilesToAdd.add(new File(files[i].getPath()));\n\t\t\t    \tSystem.out.println(\"文件：\"+files[i].getPath());\n\t    \t\t}\n\t    \t}\n\t    } else {\n\t\t\tfilesToAdd.add(new File(file.getPath()));\n\t\t}\n\t    \n\t    return filesToAdd;\n    }\n```\n\n\n具体代码请到 github 自行[下载](https://github.com/charmsongo/ziptest)\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n"},{"title":"JDK版本不同引发的https请求证书问题","url":"/2018/10/27/JDK版本不同引发的https请求证书问题/","content":"# 问题解决\n## 问题描述\n首先，服务器上跑着一个接口工程，环境是jdk8，为https请求（证书认证，但这里绕过了证书）；客户端通过https调用接口，环境是jdk7，请求时报如下错：\n```java\njavax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\n```\n## 问题分析\n\t\n这个问题出现的原因是因为开发时，我客户端用的jdk8测试，没有出现问题，然后客户那是jdk7，所以出现了这个问题，这是由于客户端与服务器所使用的SSL/TLS版本不一致。服务器使用的TLS版本高，而客户端支持的TLS版本低。**Java 8默认支持TLSv1.2版本**。\n\n## 解决过程\n**这里有两种解决办法**\n\n 1. 客户端升级为jdk8(让客户改不怎么现实，这种方法先pass)\n 2. 构造证书new SSLConnectionSocketFactory对象时加上两个属性\n \n\n *这里说下第二种解决方法，下面 SSLConnectionSocketFactory 上的注释* \n \n  get请求\n  \n```java\n/**\n * get请求\n * @param url\n * @param timeout 超时时间（毫秒）\n * @param user\n * @param code\n * @return\n */\npublic static String doGet(String url, int timeout, String user, String code) {\n\ttry {\n\t\tCloseableHttpClient client = null;\n\n\t\t/* 相信自己的CA和所有自签名的证书 */\n\t\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t\t/* 不做证书校验 */\n\t\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\n\t\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\t\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\n\t\t//发送get请求\n\t\tHttpGet request = new HttpGet(url);\n\t\trequest.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t\trequest.setHeader(\"User\", user);\n\t\trequest.setHeader(\"Code\", code);\n\t\tRequestConfig requestConfig = RequestConfig.custom()\n\t\t\t\t.setConnectTimeout(timeout)\n\t\t\t\t.setSocketTimeout(timeout).build();\n\t\trequest.setConfig(requestConfig);\n\t\tHttpResponse response = client.execute(request);\n\n\t\t/**读取服务器返回过来的json字符串数据**/\n\t\tString strResult = EntityUtils.toString(response.getEntity());\n\t\treturn strResult;\n\t}catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\treturn null;\n}\n```\npost请求\n```java\n/**\n * post请求（用于请求json格式的参数）\n * @param url 请求路径\n * @param params 请求参数\n * @param user 用户\n * @param code 秘钥\n * @return\n * @throws Exception\n */\npublic static String doPost(String url, String params, String user, String code) throws Exception {\n\n\tCloseableHttpClient httpclient = null;\n\n\t/* 相信自己的CA和所有自签名的证书 */\n\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t/* 不做证书校验 */\n\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\t\n\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t@Override\n\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\thttpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\tHttpPost httpPost = new HttpPost(url);// 创建httpPost\n\thttpPost.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\thttpPost.setHeader(\"User\", user);\n\thttpPost.setHeader(\"Code\", code);\n\tString charSet = \"UTF-8\";\n\tStringEntity entity = new StringEntity(params, charSet);\n\thttpPost.setEntity(entity);\n\tCloseableHttpResponse response = null;\n\ttry {\n\n\t\tresponse = httpclient.execute(httpPost);\n\t\t\tHttpEntity responseEntity = response.getEntity();\n\t\t\tString jsonString = EntityUtils.toString(responseEntity);\n\t\t\treturn jsonString;\n\t}\n\tfinally {\n\t\tif (response != null) {\n\t\t\ttry {\n\t\t\t\tresponse.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\thttpclient.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n具体代码请到 github 自行[下载](https://github.com/charmsongo/ifctest)\n\n如果这里不能解决您的问题请参考如下链接\n\n[链接1](https://blog.csdn.net/taiyangdao/article/details/54707184)[链接2](https://blog.csdn.net/fsafs168/article/details/82020959)"},{"title":"Linux上用Jenkins执行shell","url":"/2018/10/20/Linux上用Jenkins执行shell/","content":"\n> 执行环境： Centos 7，jdk8\n\n# 安装Jenkins\n\nJenkins是个java程序所以需要先安装jdk\n\n## Jdk安装\n\n 1. 这里先在 winsdows 上下载 jdk-8u181-linux-x64.gz [连接](https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html)；\n![这里需要登录oracle才能下载](Linux上用Jenkins执行shell/1.png)\n 2. 然后通过winscp拖到linux上的 /usr/local 路径下；\n 3. 然后解压安装；\n```javascript\n[root@localhost /]# tar -xf jdk-8u121-linux-x64.tar.gz\n[root@localhost /]# mv jdk1.8.0_121/ /usr/local/jdk  && rm -rf jdk-8u121-linux-x64.tar.gz\n```\n 4. 再配置环境变量；\n```javascript\nroot@localhost:~# vim /etc/profile\nJAVA_HOME=/usr/local/jdk/\nPATH=$JAVA_HOME/bin:$PATH\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport JAVA_HOME PATH CLASSPATH \nroot@localhost:/usr/local# source /etc/profile\n```\n\n##  安装Jenkins\n\n```javascript\n[root@localhost ~]# wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war \n```\n\n## 打开防火墙\n需要注意的是，查看防火墙是否打开，打开的话需要放开端口9000或者直接关闭防火墙\n\n - 查看防火墙状态\n```javascript\n [root@localhost local]# firewall-cmd --state\nrunning \n```\n - 关闭防火墙\n```javascript\n[root@localhost local]#  systemctl stop firewalld\n```\n - 启动防火墙\n```javascript\n[root@localhost local]#  systemctl start firewalld\n```\n - 开放端口 9000\n```javascript\n[root@localhost local]# firewall-cmd --zone=public --add-port=9000/tcp --permanent  （--permanent永久生效，没有此参数重启后失效）\nsuccess\n```\n - 更新防火墙规则\n```javascript\n[root@localhost local]# firewall-cmd --reload\nsuccess \n```\n - 查看所有开放端口\n```javascript\n[root@localhost local]#  firewall-cmd --zone=public --list-ports\n9000/tcp    \n```\n## 自定义指定端口9000启动jenkins\n```javascript\n[root@localhost ~]# java -jar jenkins.war --httpPort=9000\n```\n## 浏览器登录\n\n地址栏输入 IP:9000 ，例：192.168.2.14：9000\n![在这里插入图片描述](Linux上用Jenkins执行shell/2.png)\n\n**根据提示信息找到初始密码输入登录**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/3.png)\n\n**默认选择 安装推荐插件**\n\n##  修改管理员密码\n上一步过后会有个创建一个管理员的页面，但是我这里不好使，所以就登陆admin，然后修改admin密码\n![在这里插入图片描述](Linux上用Jenkins执行shell/4.png)\n\n**拖到最下面修改密码**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/5.png)\n\n**然后可以注销后用修改的密码登陆了**\n\n##  创建一个执行shell的任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/6.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/7.png)\n\n**然后下一步拖到最下面选择构建下拉框选**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/8.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/9.png)\n\n## 构建刚创建的Jenkins任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/10.png)\n\n\n## 查看执行结果\n![在这里插入图片描述](Linux上用Jenkins执行shell/11.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/12.png)\n\n**出现 Finished: SUCCESS 恭喜，即为执行成功**\n\n> 其它博客：\n> CSDN:https://blog.csdn.net/qq_29175301/article/details/83213252\n> OSChina:https://my.oschina.net/charmsongo/blog/2249904"},{"title":"对待金钱的思维","url":"/2018/10/12/对待金钱的思维/","content":"\n**穷人思维和富人思维**\n- 1.人越缺什么就会看重什么，越不缺什么就会看的越轻。\n- 2.穷人花钱买东西钱总是会先考虑自己还有多少钱，如果不够就不买了，如果买的话如何才能买到最实惠的东西，省钱思维；富人花钱买东西首先想到的是我想要什么，这个东西对我来说有什么用，是不是必须得，目标导向型。\n- 3.穷人思维考虑做一件事情的时候总是会忽略时间成本，喜欢用时间来换金钱，感觉多花些时间来少掏些金钱就是赚了。\n- 4.夫人思维花钱无外乎两件事情没意识为了赚钱，二是为了享受。\n- 5.减少无意义的频繁决策，节省宝贵的精力，用在有意义的事情上。\n- 6.开拓自己的视野，知道是一码事，做到是另一码事。"},{"title":"my blog's format has change","url":"/2018/10/07/my-blog-s-format-has-change/","content":"\n*你好啊*\n***\n我的博客的格式终于改变了，选择了一个 简约明朗 的样式，之后有时间我会同步更新\n技术博客。"},{"title":"你好,Hexo","url":"/2018/09/22/你好-Hexo/","content":"\n张博在床上躺着呢，\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈"},{"title":"Hello World","url":"/2018/09/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n"}]