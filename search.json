[{"title":"谈一谈你有多少决定是父母决定的","url":"/2019/02/07/谈一谈你有多少决定是父母决定的/","content":"![谈一谈你有多少决定是父母决定的](谈一谈你有多少决定是父母决定的/长大.jpg)\n\n你从小到大有多少决定是为自己做的，有多少是为他人决定的或者说是被他人决定的？\n\n从小被教育是要听妈妈的话，这种思想还被周董载入了音乐，你别说，听着还真好听。是 的，小孩子天生调皮，闹腾，听话的直接结果就是父母会轻松很多，而且农村长大的孩子都明白，父母为了生计会经常忙于奔波，基本没时间照顾上学后的孩子，听话这个方式看起来会让父母少很多教育的成本，但是，事实真的是这样吗？\n\n大家知道有一些病症是有潜伏期的，当然听妈妈话的这种教育方式也是有反噬的潜伏期的，它会剥夺孩子的疑问和思考事情的过程，还有 自我改变的动力，孩子长大后就会缺失基本抉择的能力。会对父母产生依赖，18岁本是成年的分界年龄，之后的事情自己完全有权利自己做决定，但是见过不少，处对象和结婚都要经过父母的决定和选择，工作不顺利，问问父母要不要离职再找，当然父母一般的回答是有工作干着就不错了。衣服也要父母来买或者是好看不好看父母说了算......\n\n我们曾经是个孩子，但终究是要长大的，父母不能陪我们一辈子，父母也终会变老，变成老小孩，也需要依靠我们来抉择，有些事情就是要自己去做决定的。第一批 90 后都已经 30 岁了，作为奔三的人了，不得不逼着自己长大，家庭主梁的接力棒我们要尝试着接过来了，该为父母承担家庭的压力了。\n\n现在感觉父母处理的一些事情不是特别好，请不要埋怨她们，她们没有错，只是父母在变老，她们替我们做了本该我们来抉择的抉择。\n\n![谈一谈你有多少决定是父母决定的](谈一谈你有多少决定是父母决定的/微信二维码.png)","tags":["成长","思想","人生"]},{"title":"迟到但重要的事","url":"/2019/01/31/迟到但重要的事/","content":"\n![迟到但重要的事](迟到但重要的事/001.jpg)\n> 好久没更文了，一来年底了公司有些项目结尾非常忙，当然这也是接口，二来自己最近不知道该写点什么，本来 2018 年阳历 12 月有份总结一直没来的及发，就趁这个机会记录下。\n\n30 号半夜醒来后，睡意全无，心里有事，就会休息不好，事实确实如此，想想这个毛病也是高考后遗症吧，思考太多，做的太少，自己知道这个道理，有时候身边就是少个可以提点自己的人，这个人最好是前辈，不然感觉我自己接受的层度不够，还要就是自己的执行力了，想做就去做。\n\n陈谷子烂芝麻扯皮完啦，说下困扰自己的事情，活这么大，总是有些事想不开，但是解不开又故步自封，不能没有一点进展，迷茫困扰着自己，25 岁了，我把人生以 10 年划分一个阶段，我预计先划分 4 个阶段，也就是到 65，我希望自己可以选一个可以持久坚持下去的一个方向，自己可以成长，自己可以获利，也可以沉淀。我想写作是这个方向，也有好多人确实鉴定了这点，但以我一个理科男的角度来说，很难，没有什么文采，感觉很伤，但是为何不先尝试呢，趁着年轻，多尝试犯错，第一个十年就是这样的机会，如果 35 ，岁之前还是没有什么成效或者好的方向的话，那么也就只能认命了，自己辛苦点，培养下一代出息吧。\n\n**我也初步拟定了几个方向：**\n\n 1. 「身体」身体是革命，人生会经历很多，无外乎健康。财富，女人和事业，如果给他们估个价，那身体拍最前是 1，其余的都是 0，如果 1 没了要那么多 0 等于没有，所以培养健康的生活方式，每天必须抽 30分钟到1小时锻炼，不是工作或重要事情，每天10点休息，早上6点起床，本身就有些薄弱，就需要重视起来。\n 2. 「自我塑造」包括形象和学识，也就是表面的和内在的，这可以双修，活的不要邋遢，勤快的，抽时间多看书，也许有些道理就突然就明白了，也会有输出的底蕴。\n 3. 「投资系统」这个是个重点，也可以说第二个阶段 45 岁以后可可否小有成就，看这个做的好不好了，学习上必须的，这个也看大环境，不过环境不好还可以盈利才是真本事。慢慢养鹅。\n 4. 「人脉关系」不管之前怎么样，从现在开始就要培养和细化朋友的圈子了，这就像投资系统一样，时间越长，它越像财富。\n 5. 「工作」虽然放后面也不是说不重要，而是初期经济来源都是这里，提高自己的核心竞争力，专业技能，初期也给自己一份保障。\n 6. 「产品思想」每个人都是产品经理，自己就是自己的产品，为别人打工和创业都一样，就是想让自己卖个好价钱，所以好好对自己，提高自己的影响力\n\n最后离过年没几天了，公司同事也都陆续回家了，也祝大家新年越来越牛逼。\n> *个人公号：charmsongo*\n\n\n\n\n","tags":["生活","感悟","随笔","目标","总结"]},{"title":"有些事并不是看到的那样","url":"/2019/01/05/有些事并不是看到的那样/","content":"![在这里插入图片描述](有些事并不是看到的那样/温暖.jpg)\n> 今天看到一句不错的话：不要因为干枯的落叶🍂而放弃整棵大树。\n\n- 有时候人眼看到的不一定是真是的，更别说带着偏见看到的，相亲时都强调说第一印象，对某事或某人有偏见这种现象大多都是第一印象惹得祸。a同学去了 H 公司上班，刚开始新鲜感充满了他的大脑，感觉公司还不错，后来慢慢的跟 b 同学聊天调侃自己在公司工作的过程中，发现自己公司真的有点 low，随后一到公司就会想到公司的不好，进而看公司领导和同事也会拿去和别的公司的领导同事做比较，感觉没有别人家的领导和同事好，情绪就会蔓延，殊不知，这都是因为开始对公司的偏见而衍生出对公司人的偏见。\n\n- 人都有缺点和优点，也许你只是拿公司的缺点去对比别人家公司的优点，结果肯定不如意，每个公司存在，肯定有存在的道理。它自身的竞争力，也算是优点，只有从内心开放开来，去深入感受，才会理清，也许 c 同事对自己的事非常热心，d 同事非常有耐心，给我讲东西从来不着急...\n\n- 每个结论都要弄清楚后再决定","tags":["生活","感悟","随笔"]},{"title":"胡乱随笔","url":"/2018/12/22/胡乱随笔/","content":"![在这里插入图片描述](胡乱随笔/往后余生.jpg)\n\n- 1.这个世界，该来的总会来，该走的也不会长留，现如今的同学还在你身边吗？小到小学，大到大学毕业，有的早已结婚生子，孩子都快打酱油了，也有大学同学在同一个城市拼搏，但是见面的机会却很少，这或许也是一种最熟悉的陌生人。\n\n- 2.现在是你满意的生活吗？你有多久没有发自内心开心的笑了，你又有多久没有为自己真正做过选择了。\n\n- 3.你还是那个听歌可以听一天，看书可以看一天，不着急不焦虑，就是这样等时间慢下去，即使看到彤红的晚霞也可以去欣喜大自然的神奇而忘记一天的时间已经消逝。\n\n- 4.麻木，呆滞，嫉妒，孤独……好像类似这些消极悲观的字眼都看上你了一样，总是想环绕你左右，即使你突破了它们的包围圈，它们也可以很快恢复原状。\n\n- 5.每次情绪不好的时候总想去感叹，调侃，但是却不知该向谁说起，也不知道该如何说出口，看修仙的小说，主人公一般会直接或间接的在困难的时候受到高人指点，但现实生活中遇到这样的贵人是可遇不可求的。\n\n- 6.想做一件事的时候，如果想的太多，衍生的束缚就会越多，越来越畏首畏尾，倒不如管他三七二十一，干就完了。\n\n- 7.年轻的时间就这么点，要学会珍惜，即使浪费，也要浪费在自己想做而没做的事情上，干的多了再去考虑如何才会有意义，干就完了。\n\n","tags":["life","态度"]},{"title":"推荐一个java操作ftp的工具类","url":"/2018/12/08/推荐一个java操作ftp的工具类/","content":"\n# 写在前面\n作为经常使用电脑整理文件的童鞋，应该都使用过从ftp服务器上传下载文件，那么今天就了解下如何通过java程序操作ftp服务的文件\n>首先你要知道ftp的ip，路径，端口，有操作权限的账号和密码\n\n## 1 导入jar包\n\n```javascript\n commons-net-3.6.jar\n```\n这个jar包用来设置编码，经过测试，不加也可用\n## 2 工具类中主要方法\n### 2.1 登陆ftp\n```javascript\n\t/**\n\t * 验证登录\n\t * @param ip\n\t * @param port\n\t * @param name\n\t * @param pwd\n\t * @return\n\t */\n\tpublic boolean login(String ip,int port, String name, String pwd) {\n\t\ttry {\n\t\t\tftp = new FTPClient();\n\t\t\tftp.connect(ip, port);\n\t\t\tSystem.out.println(ftp.login(name, pwd));\n\t\t\tif(!ftp.login(name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tftp.setCharset(Charset.forName(\"UTF-8\"));\n\t\t\tftp.setControlEncoding(\"UTF-8\");\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n\n> 注意：获取远程文件目录，上传和下载方法基于登陆方法\n### 2.2 获取远程文件目录\n```java\n\t/**\n\t * 获取ftp某一文件（路径）下的文件名字,用于查看文件列表\n\t * @param ip\n\t * @param port\n\t * @param name\n\t * @param pwd\n\t * @param remotedir 远程地址目录\n\t * @return\n\t */\n    public boolean getFilesName(String ip,int port, String name, String pwd, String remotedir) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //获取ftp里面，指定文件夹 里面的文件名字，存入数组中\n            FTPFile[] files = ftp.listFiles(remotedir);\n            //打印出ftp里面，指定文件夹 里面的文件名字\n            for (int i = 0; i < files.length; i++) {\n                System.out.println(files[i].getName());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n        return true;\n    }\n```\n### 2.3 上传文件\n```java\n\t/**\n     * 上传文件 方法一\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean putFileOne(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //将本地的 localpath 文件上传到ftp的根目录文件夹下面，并重命名为 remotepath中的名字\n        \t return ftp.storeFile(remotepath, new FileInputStream(new File(localpath)));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n    }\n    \n    /**\n     * 上传文件的第二种方法，优化了传输速度\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean putFileTwo(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            os = ftp.storeFileStream(remotepath);\n            fis = new FileInputStream(new File(localpath));\n            byte[] b = new byte[1024];\n            int len = 0;\n            while ((len = fis.read(b)) != -1) {\n                os.write(b,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally {\n        \tthis.close();\n\t\t}\n        return true;\n    }\n```\n### 2.4 下载文件\n\n```java\n\t/**\n     * 下载文件 方法一\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean getFileOne(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //将ftp资源中 remotepath 文件下载到本地目录文件夹下面，并重命名为 localpath 中的名字\n        \treturn ftp.retrieveFile(remotepath, new FileOutputStream(new File(localpath)));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n    }\n\t\n    /**\n     * 下载文件的第二种方法，优化了传输速度\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath  本地文件路径\n     * @return\n     */\n\tpublic boolean getFileTwo(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n\t\ttry {\n\t\t\tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis = ftp.retrieveFileStream(remotepath);\n\t\t\tfos = new FileOutputStream(new File(localpath));\n\t\t\tbyte[] b = new byte[1024];\n\t\t\tint len = 0;\n\t\t\twhile ((len = is.read(b)) != -1) {\n\t\t\t\tfos.write(b,0,len);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}finally {\n\t\t\tthis.close();\n\t\t}\n\t\treturn true;\n\t}\n```\n## 3 源码\n当然上面代码只是重要的部分，如果有问题可去github自行下载 [charmsongo](https://github.com/charmsongo/ftptest)\n>如果有什么更好的方法欢迎留言","tags":["java","ftp"]},{"title":"application.properties数据库敏感信息加密这么简单？","url":"/2018/12/01/application-properties数据库敏感信息加密这么简单？/","content":"\n# 写在前面\n俗话说：”顾客是上帝“，身为程序员的我有时会直接对接客户方提出的需求，毕竟我处在提供服务的一方，所以我也会尽量的满足临时的要求。前些天就有了一个满足漏洞检测的需求，想要把数据库的明文敏感信息加密，其实也就是密码加密，所以也就有了这篇文章，我的项目是springboot结构，修改其实也挺简单，废话少说，上代码。\n\n>这里使用的是 jasypt，而它是一个java实现的安全框架\n\n## 1.Maven的pom.xml依赖\n```javascript\n <dependency>\n     <groupId>com.github.ulisesbocchio</groupId>\n     <artifactId>jasypt-spring-boot-starter</artifactId>\n     <version>1.8</version>\n </dependency>\n```\n\n## 2.通过测试类验证加密加密\n测试类如下\n```javascript\nimport org.jasypt.encryption.pbe.StandardPBEStringEncryptor;\nimport org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;\n\n/**\n * Created By charmsongo 21:04 2018/11/30\n */\npublic class CryptorTest {\n\n    /**\n     * 加密方法\n     * @param plainText 需加密文本\n     */\n    public static void testEncrypt(String plainText) {\n        StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor();\n        EnvironmentPBEConfig config = new EnvironmentPBEConfig();\n\n        // 加密的算法，这个算法是默认的\n        config.setAlgorithm(\"PBEWithMD5AndDES\");\n        //加密的密钥，自定义\n        config.setPassword(\"CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7\");\n        standardPBEStringEncryptor.setConfig(config);\n        String encryptedText = standardPBEStringEncryptor.encrypt(plainText);\n        System.out.println(encryptedText);\n    }\n\n    /**\n     * 解密方法\n     * @param encryptedText 需解密文本\n     */\n    public static void testDecrypt(String encryptedText) {\n        StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor();\n        EnvironmentPBEConfig config = new EnvironmentPBEConfig();\n\n        // 解密的算法，需同加密算法相同\n        config.setAlgorithm(\"PBEWithMD5AndDES\");\n        //解密的密钥，需同加密密钥相同\n        config.setPassword(\"CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7\");\n        standardPBEStringEncryptor.setConfig(config);\n        String plainText = standardPBEStringEncryptor.decrypt(encryptedText);\n        System.out.println(plainText);\n    }\n\n    public static void main(String[] args){\n        testEncrypt(\"root\");\n        testDecrypt(\"TU1NovjRHGyjp7cSc6v0sQ==\");\n    }\n}\n```\n**运行main方法结果如下**\n```javascript\nTU1NovjRHGyjp7cSc6v0sQ==\nroot\n```\n\n## 3.application.properties中配置修改\n```javascript\n##mysql-----修改前配置\nspring.datasource.url=jdbc:mysql://192.168.2.105/mysql?characterEncoding=utf8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n##mysql-----修后前配置\njasypt.encryptor.password=CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7#引入密钥\nspring.datasource.url=jdbc:mysql://192.168.2.105/mysql?characterEncoding=utf8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=ENC(TU1NovjRHGyjp7cSc6v0sQ==)\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n```\n\n> 使用 jasypt 加密数据库敏感信息的任务现在就可以交工了，但是看完您会发现，这样也不是特别安全的，确实。。。所以您有什么更好的加密方法欢迎留言","tags":["java","mysql","jasypt","application.properties","springboot"]},{"title":"记录下死磕过的一个坑","url":"/2018/11/10/记录下死磕过的一个坑/","content":"\n# 写在前面\n最近公司项目提了个很正常的需求，为什么说是很正常的需求呢，保守点说，大多数的项目都会默认有这样的功能，那就是tomcat指定404页面，具体情况请听我再啰嗦啰嗦。有这么一场景，有人想攻击一家的项目，但是攻击前需要了解该公司项目的具体组成部分才可以进行真正的攻击吧，但是我也不知道该项目都有哪些目录？目录下有哪些文件？可以用笨方法就是去试，用一个大概常用的路径去访问该项目地址，比如ip/项目名/xxx,不存在的路径会看到默认的404页面会显示tomcat的版本和其它的一些信息，敏感信息会暴露，有点危险，所以我公司不想让别人看到这些，那就需要指定一个页面，找不到的路径都要转发这个页面。\n## 1.修改web.xml\n\n修改的文件路径如下，只要放在tomcat下的都走这个配置\n```javascript\n/*/*/tomcat/conf/web.xml\n```\n在web.xml文件最后添加内容如下，error-code是浏览器状态码为404就转发404.jsp页面，这里需要注意一下，我就载在了这里，location是当前运行项目的下的路径，通俗点讲就是，一个项目名为songo，那么404.jsp页面就要放在songo项目下，对应的路径就是/songo/404.jsp,其实我也不知道为什么是这样设置，但是就是这样好使了\n```javascript\n    <error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n    </error-page>\n</web-app>\n```\n**这样的话就有个问题，如果tomcat下有多个项目，那每个项目根下都要放一个相同的404.jsp页面，如果您有什么更好的办法欢迎留言**\n## 2.404页面注意问题\n404.jsp需要添加2行内容，如下\n```javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=gbk\" pageEncoding=\"gbk\" isErrorPage=\"true\"%>\n<%response.setStatus(HttpServletResponse.SC_OK);%>\n```\n**这2行主要是告诉浏览器访问服务器不存在的资源跳转的错误处理页面，但是返回正常的状态码，并且正常显示页面内容**\n另外，具体页面请到 github 自行[下载](https://github.com/charmsongo/404page)\n\n\n> 说在最后，如果有哪里有问题或写的不对的，请留言，我会尽量在第一时间给您答复\n","tags":["java","tomcat","web.xml","404"]},{"title":"ORACLE如何一次性修改用户连接数？","url":"/2018/11/08/ORACLE如何一次性修改用户连接数？/","content":"\n# oracle连接数详解\noracle连接数默认是150，当同一时间连接数大于这个数的时候就会报错，现在的解决办法为增大oracle的连接数，从150改为1500，操作如下\n## 1.修改前问题解决\n如果已经报超过连接数错误后的话，是登录不上oracle的，所以需要用命令 lsof -i:1521 查看，所有占用这个端口的进程，然后用 kill -9 PID 杀死这些进程，有可能会很多，不想一个一个杀死可以百度谷歌方法 \n\n## 2.登录oracle\n```javascript\n#切换到oracle，再登录\nsu - oracle\nsqlplus / as sysdba\n```\n## 3.查询连接数，并修改\n### 3.1使用命令 show parameter processes;\n```javascript\nSQL> show parameter processes;\nNAME                                 TYPE        VALUE\n------------------------------------ ----------- ------------------------------\naq_tm_processes                      integer     1\ndb_writer_processes                  integer     1\ngcs_server_processes                 integer     0\nglobal_txn_processes                 integer     1\njob_queue_processes                  integer     1000\nlog_archive_max_processes            integer     4\nprocesses                            integer     150\n```\n最后一行为连接数150\n### 3.2修改前需先创建 spfile 并重启 oracle 服务\n```javascript\nSQL> create spfile from pfile;\nFile created.\n\n#关闭 oracle 服务\nSQL> shutdown immediate;\nDatabase closed.\nDatabase dismounted.\nORACLE instance shut down.\n\n#启动oracle服务\nSQL> startup\nORACLE instance started.\nTotal System Global Area  835104768 bytes\nFixed Size               2257840 bytes\nVariable Size          541068368 bytes\nDatabase Buffers      289406976 bytes\nRedo Buffers      2371584 bytes\nDatabase mounted.\nDatabase opened.\n```\n### 3.3修改连接数为1500\n```javascript\nSQL> alter system set processes=1500 scope = spfile;\nSystem altered.\n\n#oracle操作要养成提交的习惯\nSQL> commit;\nCommit complete.\n\nSQL> shutdown immediate;\nDatabase closed.\nDatabase dismounted.\nORACLE instance shut down.\n\nSQL> startup\nORACLE instance started.\nTotal System Global Area  835104768 bytes\nFixed Size               2257840 bytes\nVariable Size          541068368 bytes\nDatabase Buffers      289406976 bytes\nRedo Buffers      2371584 bytes\nDatabase mounted.\nDatabase opened.\n```\n### 3.4最后验证连接数是否修改成功\n```javascript\nSQL> show parameter processes;\nNAME                                 TYPE        VALUE\n------------------------------------ ----------- ------------------------------\naq_tm_processes                      integer     1\ndb_writer_processes                  integer     1\ngcs_server_processes                 integer     0\nglobal_txn_processes                 integer     1\njob_queue_processes                  integer     1000\nlog_archive_max_processes            integer     4\nprocesses                            integer     1500\n```\n已改为1500,说明修改成功，现在可以多人痛快的连接登录oracle了\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["linux","oracle"]},{"title":"本机自定义域名映射IP","url":"/2018/11/07/本机自定义域名映射IP/","content":"\n# wins和linux设置\n其实设置很简单，修改 hosts 文件就可以了，下面详细介绍\n## 1.wins修改hosts文件\n路径如下\n```javascript\nC:\\Windows\\System32\\drivers\\etc\\hosts\n```\n打开文件在最后添加如下内容，保存即可即时生效\n```javascript\n192.168.2.1 charmsongo.com\n```\n最可能遇到的问题就是修改后保存问题了，可以参考 [链接](https://www.jb51.net/diannaojichu/133538.html)\n\n## 2.linux修改hosts文件\n路径如下\n```javascript\n/etc/hosts\n```\n使用命令「vi /etc/hosts」,同样在最后添加如下内容,然后保存即可\n```javascript\n192.168.2.1 charmsongo.com\n```\n## 3.访问方式\n访问方式的改变就更简单了，把原来 URL 中的 IP 换成改的域名即可，这里以wins上为例，如下\n```java\n#修改前url\nhttps://192.168.2.1\n\n#修改后url\nhttps://charmsongo.com/\n```\n\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["域名","IP"]},{"title":"java中文件如何加密压缩?","url":"/2018/10/27/java中文件如何加密压缩/","content":"\n# 文件加密压缩\n在现如今已经可以实现大部分功能的互联网需求中，安全成为了需要的非必需品，工作需求中会遇到对导出的 excel 报表 做加密压缩的问题，今天有时间总结一下，我这里简单列举功能代码，连带其它代码文末会一并给出。\n## 1.单个文件加密压缩\n单个文件加密方法，需传输 3 个参数：被压缩源文件，压缩目标文件和加密密钥，如下\n```javascript\n\t/**\n\t * @Title: encrypt_zip \n     * @Description:将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param src_file 待压缩文件路径\n\t * @param dst_file zip路径+文件名 \n\t * @param encode 加密密码  \n\t * @return \n\t */\n\tpublic static void encrypt_zip(String src_file, String dst_file, String encode) {\n\t\tFile file = new File(src_file);\n\n\t\tZipParameters parameters = new ZipParameters();\n\t\tparameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\tparameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); // 压缩级别\n\n\t\tparameters.setEncryptFiles(true);\n\t\tparameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\tparameters.setPassword(encode.toCharArray());//设置密码\n\n\t\ttry {\n\t\t\tZipFile zipFile = new ZipFile(dst_file);\n\t\t\tzipFile.setFileNameCharset(\"gbk\");\n\t\t\tzipFile.addFile(file, parameters);\n\n\t\t} catch (ZipException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n```\n## 2.多文件加密压缩\n\t\n多文件加密压缩和单文件类似，但是，这个方法包含上面的方法，甚至功能上可以替换上面方法，具体看下 code\n\n\n```javascript\n\t/**\n\t * @Title: zipFilesAndEncrypt \n     * @Description: 将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param srcFileName 待压缩文件路径 或 文件夹路径\n\t * @param zipFileName zip路径+文件名 \n\t * @param password 加密密码  \n\t * @return \n\t */\n    public static void zipFilesAndEncrypt(String srcFileName,String zipFileName,String password){  \n    \t\n\t    if(StrTool.is_empty(srcFileName) || StrTool.is_empty(zipFileName)){  \n\t    \tSystem.out.println(\"请求的压缩路径或者文件名有误\");\n\t    \treturn;\n\t    }  \n\t    try {  \n\t\t    ZipParameters parameters = new ZipParameters();  \n\t\t    parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\t    parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL);//压缩级别\n\t\t    if(!StrTool.is_empty(password)){  \n\t\t    \tparameters.setEncryptFiles(true);     \n\t\t\t    parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\t\t    parameters.setPassword(password);  \n\t\t    }  \n\t\t    \n\t\t    ArrayList<File> filesToAdd=getFiles(srcFileName);\n\t\t    \n\t\t    ZipFile zipFile = new ZipFile(zipFileName); \n\t\t    zipFile.setFileNameCharset(\"gbk\");\n\t\t    zipFile.addFiles(filesToAdd, parameters); \n\t    } catch (ZipException e) {  \n\t    \tSystem.out.println(\"文件压缩出错\");\n\t    \te.printStackTrace();\n\t    } \n\t}\n    \n    //通过路径获取压缩文件集合\n    private static ArrayList<File> getFiles(String srcFileName){\n    \tArrayList<File> filesToAdd = new ArrayList<File>();\n\t    File file=new File(srcFileName);\n\t    File[] files = new File[0]; \n\t    if(file.isDirectory()){\n\t    \tfiles = file.listFiles();\n\t    \tfor(int i=0;i<files.length;i++){\n\t    \t\tif(files[i].getName().endsWith(\".xls\")){//xls结尾的excel添加压缩集合\n\t    \t\t\tfilesToAdd.add(new File(files[i].getPath()));\n\t\t\t    \tSystem.out.println(\"文件：\"+files[i].getPath());\n\t    \t\t}\n\t    \t}\n\t    } else {\n\t\t\tfilesToAdd.add(new File(file.getPath()));\n\t\t}\n\t    \n\t    return filesToAdd;\n    }\n```\n\n\n具体代码请关注个人公众号【charmsongo】回复[zip]\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["java","加密","压缩"]},{"title":"JDK版本不同引发的https请求证书问题","url":"/2018/10/27/JDK版本不同引发的https请求证书问题/","content":"# 问题解决\n## 问题描述\n首先，服务器上跑着一个接口工程，环境是jdk8，为https请求（证书认证，但这里绕过了证书）；客户端通过https调用接口，环境是jdk7，请求时报如下错：\n```java\njavax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\n```\n## 问题分析\n\t\n这个问题出现的原因是因为开发时，我客户端用的jdk8测试，没有出现问题，然后客户那是jdk7，所以出现了这个问题，这是由于客户端与服务器所使用的SSL/TLS版本不一致。服务器使用的TLS版本高，而客户端支持的TLS版本低。**Java 8默认支持TLSv1.2版本**。\n\n## 解决过程\n**这里有两种解决办法**\n\n 1. 客户端升级为jdk8(让客户改不怎么现实，这种方法先pass)\n 2. 构造证书new SSLConnectionSocketFactory对象时加上两个属性\n \n\n *这里说下第二种解决方法，下面 SSLConnectionSocketFactory 上的注释* \n \n  get请求\n  \n```java\n/**\n * get请求\n * @param url\n * @param timeout 超时时间（毫秒）\n * @param user\n * @param code\n * @return\n */\npublic static String doGet(String url, int timeout, String user, String code) {\n\ttry {\n\t\tCloseableHttpClient client = null;\n\n\t\t/* 相信自己的CA和所有自签名的证书 */\n\t\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t\t/* 不做证书校验 */\n\t\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\n\t\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\t\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\n\t\t//发送get请求\n\t\tHttpGet request = new HttpGet(url);\n\t\trequest.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t\trequest.setHeader(\"User\", user);\n\t\trequest.setHeader(\"Code\", code);\n\t\tRequestConfig requestConfig = RequestConfig.custom()\n\t\t\t\t.setConnectTimeout(timeout)\n\t\t\t\t.setSocketTimeout(timeout).build();\n\t\trequest.setConfig(requestConfig);\n\t\tHttpResponse response = client.execute(request);\n\n\t\t/**读取服务器返回过来的json字符串数据**/\n\t\tString strResult = EntityUtils.toString(response.getEntity());\n\t\treturn strResult;\n\t}catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\treturn null;\n}\n```\npost请求\n```java\n/**\n * post请求（用于请求json格式的参数）\n * @param url 请求路径\n * @param params 请求参数\n * @param user 用户\n * @param code 秘钥\n * @return\n * @throws Exception\n */\npublic static String doPost(String url, String params, String user, String code) throws Exception {\n\n\tCloseableHttpClient httpclient = null;\n\n\t/* 相信自己的CA和所有自签名的证书 */\n\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t/* 不做证书校验 */\n\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\t\n\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t@Override\n\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\thttpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\tHttpPost httpPost = new HttpPost(url);// 创建httpPost\n\thttpPost.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\thttpPost.setHeader(\"User\", user);\n\thttpPost.setHeader(\"Code\", code);\n\tString charSet = \"UTF-8\";\n\tStringEntity entity = new StringEntity(params, charSet);\n\thttpPost.setEntity(entity);\n\tCloseableHttpResponse response = null;\n\ttry {\n\n\t\tresponse = httpclient.execute(httpPost);\n\t\t\tHttpEntity responseEntity = response.getEntity();\n\t\t\tString jsonString = EntityUtils.toString(responseEntity);\n\t\t\treturn jsonString;\n\t}\n\tfinally {\n\t\tif (response != null) {\n\t\t\ttry {\n\t\t\t\tresponse.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\thttpclient.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n具体代码请到 github 自行[下载](https://github.com/charmsongo/ifctest)\n\n如果这里不能解决您的问题请参考如下链接\n\n[链接1](https://blog.csdn.net/taiyangdao/article/details/54707184)[链接2](https://blog.csdn.net/fsafs168/article/details/82020959)","tags":["JDK","https","证书"]},{"title":"Linux上用Jenkins执行shell","url":"/2018/10/20/Linux上用Jenkins执行shell/","content":"\n> 执行环境： Centos 7，jdk8\n\n# 安装Jenkins\n\nJenkins是个java程序所以需要先安装jdk\n\n## Jdk安装\n\n 1. 这里先在 winsdows 上下载 jdk-8u181-linux-x64.gz [连接](https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html)；\n![这里需要登录oracle才能下载](Linux上用Jenkins执行shell/1.png)\n 2. 然后通过winscp拖到linux上的 /usr/local 路径下；\n 3. 然后解压安装；\n```javascript\n[root@localhost /]# tar -xf jdk-8u121-linux-x64.tar.gz\n[root@localhost /]# mv jdk1.8.0_121/ /usr/local/jdk  && rm -rf jdk-8u121-linux-x64.tar.gz\n```\n 4. 再配置环境变量；\n```javascript\nroot@localhost:~# vim /etc/profile\nJAVA_HOME=/usr/local/jdk/\nPATH=$JAVA_HOME/bin:$PATH\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport JAVA_HOME PATH CLASSPATH \nroot@localhost:/usr/local# source /etc/profile\n```\n\n##  安装Jenkins\n\n```javascript\n[root@localhost ~]# wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war \n```\n\n## 打开防火墙\n需要注意的是，查看防火墙是否打开，打开的话需要放开端口9000或者直接关闭防火墙\n\n - 查看防火墙状态\n```javascript\n [root@localhost local]# firewall-cmd --state\nrunning \n```\n - 关闭防火墙\n```javascript\n[root@localhost local]#  systemctl stop firewalld\n```\n - 启动防火墙\n```javascript\n[root@localhost local]#  systemctl start firewalld\n```\n - 开放端口 9000\n```javascript\n[root@localhost local]# firewall-cmd --zone=public --add-port=9000/tcp --permanent  （--permanent永久生效，没有此参数重启后失效）\nsuccess\n```\n - 更新防火墙规则\n```javascript\n[root@localhost local]# firewall-cmd --reload\nsuccess \n```\n - 查看所有开放端口\n```javascript\n[root@localhost local]#  firewall-cmd --zone=public --list-ports\n9000/tcp    \n```\n## 自定义指定端口9000启动jenkins\n```javascript\n[root@localhost ~]# java -jar jenkins.war --httpPort=9000\n```\n## 浏览器登录\n\n地址栏输入 IP:9000 ，例：192.168.2.14：9000\n![在这里插入图片描述](Linux上用Jenkins执行shell/2.png)\n\n**根据提示信息找到初始密码输入登录**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/3.png)\n\n**默认选择 安装推荐插件**\n\n##  修改管理员密码\n上一步过后会有个创建一个管理员的页面，但是我这里不好使，所以就登陆admin，然后修改admin密码\n![在这里插入图片描述](Linux上用Jenkins执行shell/4.png)\n\n**拖到最下面修改密码**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/5.png)\n\n**然后可以注销后用修改的密码登陆了**\n\n##  创建一个执行shell的任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/6.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/7.png)\n\n**然后下一步拖到最下面选择构建下拉框选**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/8.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/9.png)\n\n## 构建刚创建的Jenkins任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/10.png)\n\n\n## 查看执行结果\n![在这里插入图片描述](Linux上用Jenkins执行shell/11.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/12.png)\n\n**出现 Finished: SUCCESS 恭喜，即为执行成功**\n\n> 其它博客：\n> CSDN:https://blog.csdn.net/qq_29175301/article/details/83213252\n> OSChina:https://my.oschina.net/charmsongo/blog/2249904","tags":["linux","jenkins","shell"]},{"title":"对待金钱的思维","url":"/2018/10/12/对待金钱的思维/","content":"\n**穷人思维和富人思维**\n- 1.人越缺什么就会看重什么，越不缺什么就会看的越轻。\n- 2.穷人花钱买东西钱总是会先考虑自己还有多少钱，如果不够就不买了，如果买的话如何才能买到最实惠的东西，省钱思维；富人花钱买东西首先想到的是我想要什么，这个东西对我来说有什么用，是不是必须得，目标导向型。\n- 3.穷人思维考虑做一件事情的时候总是会忽略时间成本，喜欢用时间来换金钱，感觉多花些时间来少掏些金钱就是赚了。\n- 4.夫人思维花钱无外乎两件事情没意识为了赚钱，二是为了享受。\n- 5.减少无意义的频繁决策，节省宝贵的精力，用在有意义的事情上。\n- 6.开拓自己的视野，知道是一码事，做到是另一码事。"},{"title":"my blog's format has change","url":"/2018/10/07/my-blog-s-format-has-change/","content":"\n*你好啊*\n***\n我的博客的格式终于改变了，选择了一个 简约明朗 的样式，之后有时间我会同步更新\n技术博客。"},{"title":"你好,Hexo","url":"/2018/09/22/你好-Hexo/","content":"\n张博在床上躺着呢，\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈"},{"title":"Hello World","url":"/2018/09/16/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n"}]