[{"title":"Nginx 下载和安装","url":"/2020/03/15/Nginx-下载和安装/","content":"\n#  环境\n\n> 系统环境：CentOS 7.7\n> Nginx：nginx/1.17.9\n\n## 1.Nginx 简介\nNginx 是一个高性能的 HTTP 和反向代理 Web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。\n\nNginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。\n\nNginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在 BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上 Nginx 的并发能力在同类型的网页服务器中表现较好，中国大陆使用 Nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。\n## 2.下载\n官网下载，使用世界五百强科技企业【百度】搜索引擎搜 Nginx，目前选择最新版本 nginx-1.17.9.tar.gz\n步骤如下：\n![在这里插入图片描述](Nginx-下载和安装/nginx_1.png)\n![在这里插入图片描述](Nginx-下载和安装/nginx_2.png)\n![在这里插入图片描述](Nginx-下载和安装/ngnix_3.png)\n\n## 3.安装\n### 3.1.安装依赖\n```bash\n[root@localhost ]# yum -y install gcc pcre-devel zlib-devel openssl openssl-devel\n```\n\n### 3.2.上传并解压\n可以通过工具 Winscp，把下载好的 nginx-1.17.9.tar.gz 上传到服务器跟目录，再解压\n```bash\n[root@localhost /]# tar -zxvf nginx-1.17.9.tar.gz \n```\n### 3.3.编译安装\n```bash\n[root@localhost /]# cd nginx-1.17.9\n[root@localhost nginx-1.17.9]# ./configure\n[root@localhost nginx-1.17.9]# make && make install\n```\n默认安装位置在 ：\n```bash\n[root@localhost nginx]# pwd\n/usr/local/nginx\n```\n服务启动：\n```bash\n[root@localhost nginx]# /usr/local/nginx/sbin/nginx \n[root@localhost nginx]# ps -ef | grep nginx\nroot      39801      1  0 15:20 ?        00:00:00 nginx: master process /usr/local/nginx/sbin/nginx\nnobody    39802  39801  0 15:20 ?        00:00:00 nginx: worker process\nroot      39804  37153  0 15:20 pts/0    00:00:00 grep --color=auto nginx\n```\n现在已经起来了，但是 Linux 防火墙默认大部分端口是没开放的，现在需要放开，Nginx 端口 80(默认)\n\n```bash\n#查看防火墙状态\n[root@localhost nginx]# firewall-cmd --state\nrunning\n#放开 80 端口，（--permanent永久生效，没有此参数重启后失效）\n[root@localhost nginx]# firewall-cmd --zone=public --add-port=80/tcp --permanent\nsuccess\n#重新加载防火墙信息\n[root@localhost nginx]# firewall-cmd --reload\nsuccess\n```\n出现下图说明 Nginx 服务安装成功\n![在这里插入图片描述](Nginx-下载和安装/ngnix_4.png)\n\n ### 3.4 Nginx 常用命令\n```bash\n[root@localhost sbin]# pwd\n/usr/local/nginx/sbin\n#查看 Nginx 版本\n[root@localhost sbin]# ./nginx -V\nnginx version: nginx/1.17.9\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) \nconfigure arguments:\n#关闭 Nginx \n[root@localhost sbin]# ./nginx -s stop\n#开启 Nginx \n[root@localhost sbin]# ./nginx\n#重新加载 Nginx 配置\n[root@localhost sbin]# ./nginx -s reload\n# Nginx 配置文件\n[root@localhost sbin]# vi /usr/local/nginx/conf/nginx.conf\n```\n更多的配置在 nginx.conf 中修改，Nginx 还可以和 FastDFS 做分布式文件系统部署，更多的功能继续尝试中......\n\n> 如果有哪些不对的地方烦请指认，先行感谢","tags":["CentOS","Linux","Nginx"]},{"title":"Java 基础 String 的详解","url":"/2020/03/15/Java-基础-String-的详解/","content":"\n#  写在前面\n\n> String 算是 Java 源码中先要学习的，今天就从源码的角度来重新认识一下\n\n## 1.存储结构\n看主流的 JDK 版本 1.8 ，String 内部实际存储结构为 char 数组，源码如下：\n\n```java\npublic final class String\n    implements java.io.Serializable, Comparable<String>, CharSequence {\n    /** The value is used for character storage. */\n    private final char value[];\n\n    /** Cache the hash code for the string */\n    private int hash; // Default to 0\n    //其他内容......\n```\n\n## 2.常用方法\n### 2.1.构造方法\n其中 StringBuffer 和 StringBuilder 为参数的构造函数用的比较少，但也要知道\n```java\n\t/**\n     * String 为参数的构造方法\n     * @param  original\n     *        A {@code String}\n     */\n    public String(String original) {\n        this.value = original.value;\n        this.hash = original.hash;\n    }\n\n    /**\n     * char[] 为参数构造方法\n     * @param  value\n     *         The initial value of the string\n     */\n    public String(char value[]) {\n        this.value = Arrays.copyOf(value, value.length);\n    }\n    \n\t/**\n     * StringBuffer 为参数的构造方法\n     * @param  buffer\n     *         A {@code StringBuffer}\n     */\n    public String(StringBuffer buffer) {\n        synchronized(buffer) {\n            this.value = Arrays.copyOf(buffer.getValue(), buffer.length());\n        }\n    }\n\n    /**\n     * StringBuilder 为参数的构造方法\n     * @param   builder\n     *          A {@code StringBuilder}\n     * @since  1.5\n     */\n    public String(StringBuilder builder) {\n        this.value = Arrays.copyOf(builder.getValue(), builder.length());\n    }\n```\n\n### 2.2.equals()\nString 中 equals() 是比较两个字符串的值是否相等，== 才是比较字符串的引用是否相等，equals() 重写了父类 Object 方法，传参也为 Object 类型，方法中会通过 instanceof 判断，是 String 类型才进行下一步。\n\n这里提一下，Object 父类中 equals() 和 == 对于引用类型的作用是一样的。\n\n```java\n\t/**\n\t* @param  anObject\n     *         The object to compare this {@code String} against\n     *\n     * @return  {@code true} if the given object represents a {@code String}\n     *          equivalent to this string, {@code false} otherwise\n     *\n     * @see  #compareTo(String)\n     * @see  #equalsIgnoreCase(String)\n     */\n    public boolean equals(Object anObject) {\n        if (this == anObject) {// 对象引用相同直接返回 true\n            return true;\n        }\n        if (anObject instanceof String) {\n            String anotherString = (String)anObject;\n            int n = value.length;\n            if (n == anotherString.value.length) {\n                char v1[] = value;\n                char v2[] = anotherString.value;\n                int i = 0;\n                while (n-- != 0) {\n                    if (v1[i] != v2[i])//转化为字符数组,对比每个字符，有一个不相同就是 fasle\n                        return false;\n                    i++;\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n```\n有一个和 equels 相似的方法 **equalsIgnoreCase(String)**，忽略大小写对比，传参为 String 类型\n### 2.3.compareTo()\n compareTo() 和 equels() 处理方式类似，都是字符对比，不同的是，equels() 比较两字符串相同返回 true，不相同返回 false；compareTo() 比较两字符串相同返回 0，不相同返回 其他 int 类型数值。并且 compareTo() 只能接收 String 类型。\n\n还有一个和 compareTo() 比较类似的方法 compareToIgnoreCase()，用于忽略大小写后比较两个字符串。\n\n```java\n\t/**\n     * @param   anotherString   the {@code String} to be compared.\n     * @return  the value {@code 0} if the argument string is equal to\n     *          this string; a value less than {@code 0} if this string\n     *          is lexicographically less than the string argument; and a\n     *          value greater than {@code 0} if this string is\n     *          lexicographically greater than the string argument.\n     */\n    public int compareTo(String anotherString) {\n        int len1 = value.length;\n        int len2 = anotherString.value.length;\n        int lim = Math.min(len1, len2);\n        char v1[] = value;\n        char v2[] = anotherString.value;\n\n        int k = 0;\n        while (k < lim) {\n            char c1 = v1[k];\n            char c2 = v2[k];\n            if (c1 != c2) {\n                return c1 - c2;\n            }\n            k++;\n        }\n        return len1 - len2;\n    }\n```\n\n### 2.4.其他重要方法\n\n - indexOf()：查询字符串首次出现的下标位置 \n - lastIndexOf()：查询字符串最后出现的下标位置\n -  contains()：查询字符串中是否包含另一个字符串 \n - toLowerCase()：把字符串全部转换成小写\n - toUpperCase()：把字符串全部转换成大写 \n - length()：查询字符串的长度 \n - trim()：去掉字符串首尾空格\n - replace()：替换字符串中的某些字符 \n - split()：把字符串分割并返回字符串数组 \n - join()：把字符串数组转为字符串\n\n## 3.常遇问题\n### 3.1.String 和 StringBuilder、StringBuffer 的区别\nString 是不可变的，在字符串拼接的时候使用 String 会很耗性能，因此有了 StringBuilder 和 StringBuffer，它们有 2 方法 append 和 insert 可以实现字符串拼接，唯一不同的是 StringBuffer 使用 synchronized 来保证线程安全\n\n```java\n//StringBuffer 截取片段，具体可以看 StringBuffer 类源码\n\n\t@Override\n    public synchronized StringBuffer append(Object obj) {\n        toStringCache = null;\n        super.append(String.valueOf(obj));\n        return this;\n    }\n\n    @Override\n    public synchronized StringBuffer append(String str) {\n        toStringCache = null;\n        super.append(str);\n        return this;\n    }\n    //其他......\n\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public synchronized StringBuffer insert(int offset, Object obj) {\n        toStringCache = null;\n        super.insert(offset, String.valueOf(obj));\n        return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public synchronized StringBuffer insert(int offset, String str) {\n        toStringCache = null;\n        super.insert(offset, str);\n        return this;\n    }\n   //其他......\n```\n\n```java\n//StringBuilder截取片段，具体可以看 StringBuilder类源码\n\n \t@Override\n    public StringBuilder append(Object obj) {\n        return append(String.valueOf(obj));\n    }\n\n    @Override\n    public StringBuilder append(String str) {\n        super.append(str);\n        return this;\n    }\n\t//其他......\n\n\n\t/**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, Object obj) {\n            super.insert(offset, obj);\n            return this;\n    }\n\n    /**\n     * @throws StringIndexOutOfBoundsException {@inheritDoc}\n     */\n    @Override\n    public StringBuilder insert(int offset, String str) {\n        super.insert(offset, str);\n        return this;\n    }\n    //其他......\n```\nStringBuffer 保证线程安全，所以性能不是很高,JDK 1.5 就有了 StringBuilder\n\n### 3.2.String 为什么用 final 修饰\n使用 final 修饰的第一个好处是**安全**；第二个好处是**高效**,例如\n\n\n```java\nString s1 = \"java\";\nString s2 = \"java\";\n```\n只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：\n![在这里插入图片描述](Java-基础-String-的详解/final_a.png)\n\n### 3.3.JVM 中存储\nString 常用的 2 种创建方式，有 String a1 = \"java\" 和 String a2 = new Strring(\"java\"),但他们在内存中的存放方式不同，JDK1.8 中创建啊变量 a1，会先从常量池中找字符串 “java”,如果有直接返回，如果没有则先在常量池中创建该字符串再返回，而变量 a2会直接在堆内存上创建，a2 调用方法 intern() 会把字符串保存到常量池，例如\n\n```java\nString a1 = \"java\";\nString a2 = new Strring(\"java\");\nString a3 = \"a2.intern();\n\nSystem.out.println(a1 == a2); // false\nSystem.out.println(a1 == a3); // true\n```\nJVM 存储位置如图\n![在这里插入图片描述](Java-基础-String-的详解/jvm_1.png)\nPS:JDK 1.7 之后把永生代换成的元空间，把字符串常量池从方法区移到了 Java 堆上。\n\n结束......\n\n> 如果有哪些不对的地方烦请指认，先行感谢","tags":["Java","String","String源码"]},{"title":"CentOS 7 安装 RabbitMQ","url":"/2020/02/03/CentOS-7-安装-RabbitMQ/","content":"\n\n\n#  环境准备\n\n> 基础系统：CentOS 7.6 \n> Erlang 和 RabbitMQ 需要版本对应，参考 [这里](https://www.rabbitmq.com/which-erlang.html)，本次使用如下版本\n> Erlang：otp_src_22.0.tar.gz （RabbitMQ 是基于 Erlang 语言开发的，所以必须先安装 Erlang）\n> RabbitMQ：rabbitmq-server-generic-unix-3.7.15.tar.xz\n\n## 1.下载并上传对应版本的软件包\n### 1.1.Erlang 下载\n**erlang官网**：https://www.erlang.org/downloads\n\notp_src_22.0.tar.gz（ 1 慢就用 2 ） [下载 1](http://erlang.org/download/otp_src_22.0.tar.gz) [下载 2](https://pan.baidu.com/s/1TOCkB2o5LVhkmIJJoYaanw)\n\n### 1.2.RabbitMQ 下载\n**下载地址**：https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.15\n\nrabbitmq-server-generic-unix-3.7.15.tar.xz [下载](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.15/rabbitmq-server-generic-unix-3.7.15.tar.xz)\n\n### 1.3. 上传\n 通过 WinScp 把两个文件拖到服务器的目录 /usr/local/\n\n## 2.安装依赖\n\n```bash\nyum -y install gcc glibc-devel make ncurses-devel openssl-devel xmlto perl wget gtk2-devel binutils-devel\n```\n\n## 3.Erlang 安装\n```bash\n[root@localhost /]# cd /usr/local/\n\n#解压\n[root@localhost local]#  tar -zxvf otp_src_22.0.tar.gz\n\n#创建安装目录\n[root@localhost local]#  mkdir erlang\n\n#切换目录\n[root@localhost local]# cd otp_src_22.0\n\n#配置安装路径\n[root@localhost otp_src_22.0]# ./configure --prefix=/usr/local/erlang\n```\n如果遇到如下界面，百度说不用管，那咱们就继续下一步\n![在这里插入图片描述](CentOS-7-安装-RabbitMQ/erlang_err.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTc1MzAx,size_16,color_FFFFFF,t_70)\n\n```bash\n#安装\n[root@localhost otp_src_22.0]# make install\n\n#查看是否安装完成\n[root@localhost otp_src_22.0]# cd /usr/local/erlang/\n[root@localhost erlang]# ls -l\n总用量 0\ndrwxr-xr-x. 2 root root 128 1月  21 15:40 bin\ndrwxr-xr-x. 3 root root  20 1月  21 15:39 lib\n\n#配置 Erlang 环境变量\n[root@localhost erlang]# echo 'export PATH=$PATH:/usr/local/erlang/bin' >> /etc/profile\n\n#刷新环境变量\n[root@localhost erlang]# source /etc/profile\n\n#验证是否成功\n[root@localhost erlang]# cd /\n[root@localhost /]# erl\nErlang/OTP 22 [erts-10.4] [source] [64-bit] [smp:1:1] [ds:1:1:10] [async-threads:1] [hipe]\n\nEshell V10.4  (abort with ^G)\n1> \n\n#输入 halt(). 命令退出（没看错，有点）\n1> \n1> halt().\n[root@localhost /]# \n```\n\n## 4.RabbitMQ 安装\n\n```bash\n#tar.xz 文件需要命令 xz，没有的话就先安装 \n[root@localhost /]# cd /usr/local/\n[root@localhost local]# yum install -y xz\n\n#解压\n[root@localhost local]# xz -d rabbitmq-server-generic-unix-3.7.15.tar.xz  \n[root@localhost local]# tar -xvf rabbitmq-server-generic-unix-3.7.15.tar\n\n#文件夹重命名\n[root@localhost local]# mv rabbitmq_server-3.7.15  rabbitmq\n\n#配置 RabbitMQ 环境变量\n[root@localhost local]# echo 'export PATH=$PATH:/usr/local/rabbitmq/sbin' >> /etc/profile\n\n#刷新环境变量\n[root@localhost local]# source /etc/profile\n\n#验证服务是否安装成功\n#服务启动\n[root@localhost local]# rabbitmq-server -detached\nWarning: PID file not written; -detached was passed.\n\n#服务状态\n[root@localhost local]# rabbitmqctl status\n\n#服务关闭\n[root@localhost local]# rabbitmqctl stop         \nStopping and halting node rabbit@localhost ...\n\n```\n\n## 5.安装 WEB 管理界面\n\n```bash\n#安装\n[root@localhost local]# rabbitmq-plugins enable rabbitmq_management\n\n#防火墙放开端口 5672 和 15672\n[root@localhost local]#  firewall-cmd --zone=public --add-port=5672/tcp --permanent  \nsuccess\n[root@localhost local]#  firewall-cmd --zone=public --add-port=15672/tcp --permanent\nsuccess\n\n#查看防护墙端口是否放开\n[root@localhost local]# firewall-cmd --query-port=15672/tcp\nno\n[root@localhost local]# firewall-cmd --query-port=5672/tcp \nno\n\n#重启防火墙\n[root@localhost local]# firewall-cmd --reload\nsuccess\n\n#查看防护墙端口是否放开\n[root@localhost local]# firewall-cmd --query-port=5672/tcp\nyes\n[root@localhost local]# firewall-cmd --query-port=15672/tcp\nyes\n\n```\n\n浏览器访问：ip:15672 如下图\n\n![在这里插入图片描述](CentOS-7-安装-RabbitMQ/rabbitmq_login.png)\n\n*默认账号密码：guest guest（这个账号只允许本机访问）*\n\n## 6.RabbitMQ 用户管理 \n\n```bash\n#查看所有用户\n[root@localhost local]# rabbitmqctl list_users\nListing users ...\nuser    tags\nguest   [administrator]\n\n#添加一个用户和密码\n[root@localhost local]# rabbitmqctl add_user charmsongo 123456\nAdding user \"charmsongo\" ...\n\n#配置权限\n[root@localhost local]# rabbitmqctl set_permissions -p \"/\" charmsongo \".*\" \".*\" \".*\"      \nSetting permissions for user \"charmsongo\" in vhost \"/\" ...\n\n查看 charmsongo 权限\n[root@localhost local]# rabbitmqctl list_user_permissions charmsongo\nListing permissions for user \"charmsongo\" ...\nvhost   configure       write   read\n/       .*      .*      .*\n\n#设置 tag 为 administrator\n[root@localhost local]# rabbitmqctl set_user_tags charmsongo administrator\nSetting tags for user \"charmsongo\" to [administrator] ...\n[root@localhost local]# rabbitmqctl list_users\nListing users ...\nuser    tags\ncharmsongo      [administrator]\nguest   [administrator]\n\n#删除默认用户（安全起见）\n[root@localhost local]# rabbitmqctl delete_user guest\nDeleting user \"guest\" ...\n```\n\n## 7.登录验证\n用新账号和密码登录（如果失败，可重启 RabbitMQ 服务）\n\n![在这里插入图片描述](CentOS-7-安装-RabbitMQ/rabbitmq_config.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTc1MzAx,size_16,color_FFFFFF,t_70)\n\n结束......\n\n> 如果有哪些不对的地方烦请指认，先行感谢","tags":["CentOS","RabbitMQ","Linux","Erlang"]},{"title":"初识 IPv4 和 IPv6","url":"/2020/01/20/初识-IPv4-和-IPv6/","content":"\n# 前言\n\n> 2019 年 11 月 26 日，全球所有 43 亿个 IPv4 地址已分配完毕。\n\n## 1.IPv4\n\n\nIPv4是 Internet Protocol version 4 的缩写，中文翻译为互联网通信协议（TCP/IP协议）第四版，通常简称为网际协议版本 4。\n\nIPv4 使用32位地址，4 字节，一共有 4,294,967,296（2^32）个。\n\nIPv4 写为点分十进制的形式，格式为 nnn.nnn.nnn.nnn，4 个字节以点分割分为 4 段，每段一个字节，一个字节有 8 位，能表示的数字位 0-255，0<=nnn<=255。可省略前导 0。\n\nTCP/IP 五层协议模型中，一次网络请求的经过为 应用层->传输层->网络层->数据链路层->物理层。一个请求数据也会从应用层到物理层经过层层包装。IPv4 作为网络层协议，在其报文结构中，同样包含了 IP 首部和数据部分，IPv4 的首部长度是可变的，范围在 20-60 字节之间。\n## 2.IPv6\nIPv6 是 Internet Protocol version 6 的缩写，中文翻译为互联网通信协议（TCP/IP协议）第 6 版，通常简称为网际协议版 6。IPv6 具有比 IPv4 大得多的编码地址空间，用它来取代 IPv4 主要是为了解决 IPv4 地址枯竭问题，同时它也在其他方面对于 IPv4 有许多改进。\n\nIPv6 使用 128 位地址，16 字节，340,282,366,920,938,463,463,374,607,431,768,211,456（2^128）个。\n\nIPv6 写为冒号 分 十六进制的形式，格式为 xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx，16 个字节以冒号分割分为 8 段，每段 2 个字节，一个字节有 8 位。可省略前导 0。\n\n和 IPv4 一样，IPv6 的报文中同样包含首部和数据部分。IPv6 报文的首部是 40 个字节的固定长度。IPv6的头部内容比 IPv4 少了很多。在报文上，IPv6 和 IPv4 的主要区别是报文头的区别。\n\n##  3.演进\n<img src=\"初识-IPv4-和-IPv6/ipv4_ipv6.png\" alt=\"在这里插入图片描述\" style=\"zoom:75%;\" />\n\n**IPv6 并不是 IPv4 协议的的升级，而是一个全新的协议，二者之间是无法互相兼容的。**\n\n为了保障 IPv4 向 IPv6 的顺利演进，国际互联网工程任务组（IETF）成立专门工作组进行研究，形成了三类技术方案：双栈技术、隧道技术、协议转换技术（NAT-PT）。\n\n> 具体深入内容可以查阅资料，如果有哪些不对的地方烦请指认，先行感谢","tags":["网络协议","IPv4","IPv6"]},{"title":"代码混淆神器 Allatori","url":"/2019/09/28/代码混淆神器-Allatori/","content":"\n#  准备工作\n\n> 此次案例使用官方 Demo，不使用任何插件\n> 环境：windows 10\n\n## 1.Allatori简介\n\n> **Allatori** 是第二代 Java 混淆器，可为您的知识产权提供全方位的保护。\n>\n> **尽管**大多数第二代混淆器都提供了值得保护的级别，但我们已经在Allatori中开发了许多附加功能，以使对代码进行逆向工程几乎不可能。\n>\n> **Allatori** 不仅会混淆，还会最大程度地减少应用程序的大小并提高速度，同时您和您的团队以外的任何人都无法读取您的代码。作为每个现代 Java 混淆器，Allatori 具有完整的水印功能，从而有可能为您的软件提供适当的许可！\n>\n> **如果**有必要保护您的软件，并且要减少软件的大小和缩短处理时间，则可以使用 Allatori 混淆器。\n\n&nbsp;- - 摘自ALLATORI JAVA混淆器官网\n## 2.下载\n\n 1.官网最新 Allatori-7.1-Demo.zip [下载](http://www.allatori.com/downloads/Allatori-7.1-Demo.zip)\n 2.CSDN[下载](https://download.csdn.net/download/qq_29175301/11828078)（包含反编译工具 jd-gui.exe）\n\n## 3.内容简介\n\n 1.解压下载的压缩包 Allatori-7.1-Demo.zip\n 然后进入目录 xx/Allatori-7.1-Demo\\tutorial\\step01\\files\n\n2.目录如下内容\n![Allatori-7.1-Demo\\tutorial\\step01\\files](https://img-blog.csdnimg.cn/20190928120722147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MTc1MzAx,size_16,color_FFFFFF,t_70)\n\n - **Clean.bat**:清除 log.xml 以及生成混淆的文件\n - **config.xml**：混淆的配置文件\n - **mousegestures-1.2.jar、test.jar**：被混淆的 jar 包\n - **MouseGesturesOriginal.bat**：混淆前 jar 的测试命令\n - **MouseGesturesObfuscated.bat**：混淆后 jar 的测试命令\n - **RunAllatori.bat**：执行生成混淆 jar 的命令\n\n3.config.xml 详解\n\n> 混淆的成功与否在于次配置的对与错。官方默认对除了 public 修饰的类、方法、区域放开，其余的都会混淆处理\n\n```bash\n<config>\n    <input>\n        <jar in=\"test.jar\" out=\"obf-test.jar\"/>\n        <jar in=\"mousegestures-1.2.jar\" out=\"obf-mousegestures-1.2.jar\"/>\n    </input>\n\n    <keep-names>\n        <class access=\"protected+\">\n            <field access=\"protected+\"/>\n            <method access=\"protected+\"/>\n        </class>\n    </keep-names>\n\n    <property name=\"log-file\" value=\"log.xml\"/>\n</config>\n\n```\n\n```bash\n<jar in=\"你的 jar 包名称.jar\" out=\"混淆后的 jar 包名称.jar\"/>\n```\n\n## 4.使用\n\n 1. 把需要混淆的 jar 包放到刚才的目录下\n 2. 修改 config.xml的 jar 部分，写上被混淆 jar 的名字和混淆后 jar 的名字\n 3. 双击 RunAllatori.bat，会生成一个新 jar\n## 5.测试\n1.如果双击 MouseGesturesOriginal.bat 和 MouseGesturesObfuscated.bat 的结果一样，说明混淆成功。\n2.使用反编译工具 jd-gui.exe 查看混淆后的 jar 包，会发现除了public 修饰的方法都被混淆\n\n> 注意：常量的值不会被混淆，处理方案是，放到方法中即可实现混淆\n> 如果有哪些不对的地方烦请指认，先行感谢","tags":["Java","Allatori","jd-gui.exe","反编译","混淆器"]},{"title":"职场近期的思考","url":"/2019/09/01/职场近期的思考/","content":"\n> 职场的一些心得感悟，记录下来吧。\n\n\n\n作为一个职场人，首先要明白的是已经踏入了社会，理解一个因果关系，是先为公司创造价值才收获薪资回报。\n\n\n\n***<font color=green size=5>1.</font>***成人思维。大家都是成年人，就该有成年人的思维，谁也没有义务帮你做事情，解决问题，如果同事有时间帮你看问题解决问题，那是荣幸，该有些小殷勤的也不为过。\n\n\n\n***<font color=green size=5>2.</font>***自我驱动。自我学习很重要，不要等着要用了才去学，那样你已经比别人晚了不止一点两点了。多看看别人用什么技术，即使当时看了很懵，但是记住名字后上百度能找到详解吧，在这个开卷的职场考试中，其实完成工作已经很容易了。重要的是要有这个意识，别总是等着别人解决，不然公司招你的目的是什么，不要说的太露骨。\n\n\n\n***<font color=green size=5>3.</font>***认清自己。其实有些事情还可以做的更好，一份任务中如果没有被领导批评，心里就会默认做的还行吧，事实上不是这样子的，有可能领导是有更紧急的事情要处理，没有精力再花时间指导你，但领导心里已经知道你的态度和水平了。所以不要觉的能完成任务自己就很优秀，你没有升职加薪没想过原因吗？中国人口 14 亿人，不要做井底之蛙，跳出来看看，思维要与行业接轨，不断的进取才是良策。不管别人技术和思维如何，做好自己就是了。\n\n\n\n不断反省和调整，找到自己舒服的方式前进。","tags":["职场","自我驱动"]},{"title":"Linux下 keepalived 的安装和配置","url":"/2019/08/18/Linux下-keepalived-的安装和配置/","content":"\n#  安装前准备\n\n> 基础系统：CentOS 7 \n\n```shell\nyum -y install gcc gcc-c++ autoconf automake make \nyum -y install zlib zlib-devel openssl openssl-devel pcre pcre-devel\n```\n\n## 1.下载keepalived\n**方法一：**\n\n```shell\nyum -y install keepalived\n```\n   **方法二**：\n   下载二进制源码包：http://www.keepalived.org/download.html \n\n```shell\n#下载安装文件\n\ncd /usr/local\nwget http://www.keepalived.org/software/keepalived-2.0.18.tar.gz\n#解压文件\ntar -zxvf keepalived-2.0.18.tar.gz\n#编译\ncd keepalived-2.0.18/\n#--prefix 指定安装地址\n#/usr/local/keepalived/ 安装的目录，不要和自己安装文件一个目录，不然报错\n./configure --prefix=/usr/local/keepalived/\n#编译并安装\n make && make install\n```\n\n## 2.配置\n\n **复制文件：**\n```shell\n[root@localhost ~]# cp /usr/local/keepalived-2.0.18/keepalived/etc/init.d/keepalived /etc/init.d/\n[root@localhost ~]# mkdir /etc/keepalived\n[root@localhost ~]# cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/\n[root@localhost ~]# cp /usr/local/keepalived-2.0.18/keepalived/etc/sysconfig/keepalived /etc/sysconfig/\n[root@localhost ~]# cp /usr/local/keepalived/sbin/keepalived /usr/sbin/\n```\n\n\n**编辑：**\n\n```\nvi /etc/keepalived/keepalived.conf\n```\n /etc/keepalived/keepalived.conf内容如下\n```shell\nglobal_defs {\n    notification_email {\n        #mr@mruse.cn       # 指定keepalived在发生切换时需要发送email到的对象，一行一个\n        #sysadmin@firewall.loc\n    }\n    notification_email_from xxx@163.com   # 指定发件人\n    smtp_server smtp@163.com              # smtp 服务器地址\n    smtp_connect_timeout 30               # smtp 服务器连接超时时间\n    router_id LVS_1 # 必填，标识本节点的字符串,通常为hostname,但不一定非得是hostname,故障发生时,邮件通知会用到\n    }\n\nvrrp_script chk_tomcat {\t\t\t\t\t#详细看下面\n\tscript \"/etc/keepalived/tomcat_check.sh\"\t\t\t#检测服务shell\n\tinterval 2\t\t\t\t\t\t\t\t\t#每个多长时间探测一次\n\tweight -20\t\t\t\t\t\t\t\t\t\t\t#每个多长时间探测一次\t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n_instance VI_1 {  # 实例名称\n    state MASTER      #  必填，可以是MASTER或BACKUP，不过当其他节点keepalived启动时会将priority比较大的节点选举为MASTER\n    interface ens33    #  必填， 节点固有IP（非VIP）的网卡，用来发VRRP包做心跳检测\n    mcast_src_ip 192.168.2.89 #本机的ip，需要修改\n    virtual_router_id 101 #  必填，虚拟路由ID,取值在0-255之间,用来区分多个instance的VRRP组播,同一网段内ID不能重复;主备必须为一样;\n    priority 100      #  必填，用来选举master的,要成为master那么这个选项的值最好高于其他机器50个点,该项取值范围是1-255(在此范围之外会被识别成默认值100)\n    advert_int 1      #  必填，检查间隔默认为1秒,即1秒进行一次master选举(可以认为是健康查检时间间隔)\n    authentication {  #  必填，认证区域,认证类型有PASS和HA（IPSEC）,推荐使用PASS(密码只识别前8位)\n        auth_type PASS  # 默认是PASS认证\n        auth_pass 1111 # PASS认证密码\n    }\n    virtual_ipaddress {\n        192.168.2.90    #  必填，虚拟VIP地址,允许多个\n    }\n    track_script {\t\t # 检测shell\t\t\t\t\t\t\t\n\t\tchk_tomcat\n\t}\n}\n```\nvrrp_script 里的script返回**值为0**时认为**检测成功**，**其它值**都会当成**检测失败**；\n\n 1. **weight 为正时**，**脚本检测成功时此weight会加到priority上**，检测失败时不加；\nA.主失败：主 priority < 从 priority + weight 时会切换。\nB.主成功：主 priority + weight > 从 priority + weight 时，主依然为主\n 2. **weight 为负时**，**脚本检测成功时此weight不影响priority**，检测失败时priority – abs(weight)\nA.主失败：主 priority – abs(weight) < 从priority 时会切换主从\nB.主成功：主 priority > 从priority 主依然为主\n\n**检测shell：/etc/keepalived/tomcat_check.sh 可以根据 tomcat 服务检测结果返回不同的值，成功执行 exit 0 返回 0，失败执行 exit 1 返回 1，vrrp_script 可以结合返回值来对当前keepalived优先级做处理**\n\n## 3.开启服务\n设置 keepalived 服务开机启动\n\n```shell\n# chkconfig keepalived on  \n# 启动keepalived 服务\n# service keepalived start \n```\n查看keepalived进程，出现如下三个进程即为启动成功\n\n```\n[root@localhost ~]# ps -ef | grep keep\nroot       7925      1  0 11:27 ?        00:00:00 /usr/local/keepalived/sbin/keepalived -D\nroot       7926      1  0 11:27 ?        00:00:00 /usr/local/keepalived/sbin/keepalived -D\nroot       7927   7926  0 11:27 ?        00:00:00 /usr/local/keepalived/sbin/keepalived -D\nroot       7956   7888  0 12:02 pts/1    00:00:00 grep --color=auto keep\n```\n\n## 4.指定日志的输出文件\n\n修改 /etc/sysconfig\n\n```shell\nvim  /etc/sysconfig\n#指定位置修改为如下内容\nKEEPALIVED_OPTIONS=\"-D -d -S 0\"\n```\n修改 /etc/rsyslog.conf\n```shell\nvim /etc/rsyslog.conf\n#在最后一行添加如下内容\nlocal0.* /var/log/keepalived.log\n```\n重启服务测试\n\n```shell\nservice rsyslog restart\nservice rsyslog restart\n\n#如下命令有日志内容输出即为成功\ntailf /var/log/keepalived.log\n\n#centos 基本可以成功，但是 debain 可能失败，失败上面 2 个文件可以改为如下内容，再重启服务测试\nKEEPALIVED_OPTIONS=\"-D -d -S 1\"\nlocal1.* /var/log/keepalived.log\n```\n\n参考：https://blog.csdn.net/weixin_33845881/article/details/86016142\n\n> 如果有哪些不对的地方烦请指认，先行感谢\n\n欢迎关注公号：charmsongo","tags":["linux","centos","keepalived","高可用"]},{"title":"Map简单记录","url":"/2019/07/16/Map简单记录/","content":"\n# Map 笔记\n\n今天学习了 map 中的 hashMap 和 concurrentHashMap 区别，简单记录下。\n\n## 1.JDk1.7\n**hashmap：**\n\n 1. hashmap 是数组和链表的组合结构，线程不安全\n 2. hashmap 默认长度为 16，默认加载因子为 0.75，hashmap 添加数据时，添加后的长度大于等于原来长度*加载因子时会扩容，默认增加为原来的 2 倍\n 3. hashmap 指定长度和加载因子初始化构造方法时，hashmap 的长度初始化为大于等于指定长度的 2 的次方的值\n 4. hashmap 的长度总是为 2 的次方，主要是为了方便通过寻找到 entry 对象存在那个数组节点。\n 5. put() 方法操作时，先通过 hashcode 位运算和与运算后得到 hash，再通过 hash & (hashmap长度-1) 寻找到entry对象存在那个数组节点，然后得到这个节点存放的链表，如果为 null，直接存放，如果不为 null,则通过 key 判断是否有自己存放的 key 的  entry，有直接替换 value，返回 oldvalue，如果没有判断链表长度，最后放在链表头部，然后存放链表原来头部 entry 的下标 next，链表下移\n 6. 扩容时，数组元素中链表的顺序和原来存放的顺序刚好相反，并且会出现死循环的问题\n\n   **hashtable**：线程安全，给 put() 方法加了个 synchronized，效率慢 \n   **concurrentHashMap：**    构造方法中比 hashmap 多个级别level的参数，该 map 把一个entry数组分为了 level 个，segment，并且每个都加锁，每个 segment 的长度为 map 的长度/level\n\n## 2.JDK1.8\n\n **hashmap：**\n相对于 jdk1.7 的区别：\n 1. put() 方法插入元素，追加在链表的尾部，而不是插入头部再向下移动一位\n 2. 链表长度大于等于8时会树化为红黑树结构\n\n**concurrentHashMap：**\n相对于 jdk1.7 的区别：没有了 segment。因为每次操作都会设计链表的第一个元素，所以只给链表第一位元素加锁\n\n\n> 如果有哪些不对的地方烦请指认，先行感谢","tags":["JDK","JAVA","MAP"]},{"title":"MYSQL学习笔记one","url":"/2019/07/07/MYSQL学习笔记one/","content":"\n\n\n# MYSQL 笔记\n\n好久没写博客了，感觉时间过的好快，虽然没更文，但是自己没有放弃记录输出，这次记录下学习 MySQL 的一些知识。\n\n## 1.MYSQL 中 NULL 和空值区别\n\n 1. 空值长度为 0，null 没有长度，显示 null\n 2. 函数 count 默认把列中 null 行去掉，空值会计算，函数 ifnull(parm1,parm2) 意为当 parm1 为 null 值时，结果为 parm2，不为null 时，结果为 parm1\n 3. MYSQL 中，普通索引和复合索引有值为 null 时是走索引的，资料上说**空间索引**不走\n 4. explain 可以查看语句执行详情\n 5. show keys(indexes) from table 查看表索引\n 6. 全部插入 null 会报错\n-- 1048 - Column 'one' cannot be null\n 7. 添加索引\n-- ALTER TABLE table_name ADD INDEX index_name(col_name);\n--ALTER TABLE tb_test ADD INDEX index_oat (one, two);\n--ALTER TABLE tb_test add INDEX index_two(two);\n\n\n## 2.MYSQL触发器\n\n 1. 显示库触发器 show triggers;\n**SHOW TRIGGERS [FROM schema_name];**\n其中可选参数 schema_name 即 Schema 的名称，在 MySQL 中 Schema 和 Database 相关，查看时可以指定数据库名。指定后会从指定的数据库查询，不定则从 USE database_name;切换的，当前工作数据库查询。\n 2. 创建触发器\n**CREATE TRIGGER <触发器名称>\n{ BEFORE | AFTER }\n{ INSERT | UPDATE | DELETE } \nON <表名称>\nFOR EACH ROW\n<触发的SQL语句>**\n触发器名称 -- 触发器名字，最多 64 个字符，其命令规则和 MySQL 中其他对象的命名方式类似\n{ BEFORE | AFTER } -- 触发器执行时间：可以设置为事件发生前或后\n{ INSERT | UPDATE | DELETE } -- 触发事件：可以设置为在执行 INSERT、UPDATE、DELETE 操作时触发\n表名称 -- 触发器所属表：触发器属于某一个表，当在这个表上执行 INSERT、UPDATE、DELETE 操作的时就会使触发器触发，一张表的同一个事件只能有一个触发器\nFOR EACH ROW -- 触发器的执行间隔：FOR EACH ROW 子句通知触发器，每行执行一次动作\n触发的 SQL 语句 -- 事件触发时所要执行的SQL语句。\n例:\nmysql> DELIMITER $   //将SQL语句的结束符设置为#\nmysql> CREATE TRIGGER t_after_insert_userRoles\nAFTER INSERT ON\nuserRoles\nFOR EACH ROW\nBEGIN\n    update users set isManager = 1 where userId = new.userId and new.roleId = 1;\nEND$\nmysql> DELIMITER ;   //将 SQL 语句的结束符设重置为;以不影响后续使用\n 3. 删除触发器\n**DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name;**\n\n\n## 3.MYSQL 数据库的事务\n\n **特性:**\n 1. 原子性（Atomicity）*事务中的程序对数据库的修改操作要么全部成功，要么全部失败*\n 2. 一致性（Consistency）*事务执行前和执行后数据的来源和去向保持平衡*\n 3. 隔离性（Isolation）*并发时每个事务相互不影响，互相隔离*\n 4. 持久性（Durubility）*事务一旦提交成功，应保证数据的完整存在*\n\n  **隔离级别:**\nA.读取未提交\nB.读取已提交\nC.可重复读(mysql默认级别)\nD.可串行化(会导致大量超时现象和锁竞争)\n\noracle数据库支持两种B和D，默认为B\n\n\n\n## 4.MYSQL 数据库 SQL 优化\n\n 1. explain+sql查看语句执行计划，type是sql语句查询的类型all是没有走索引，ref、eq_ref是走索引，type为index_merge，extra有intersect是并集索引\n 2. create index 名字_index on table(加索引字段,…)，建单个或者联合索引\n 3. show warnings;是查询优化后的语句\n 4. 查询的结果集为个别时，where后的条件都加索引\n 5. 多表连接的字段上需要建立索引\n 6. where条件字段上需要建立索引\n 7. 排序字段上需要建立索引\n 8. 分组字段上需要建立索引\n 9. Where条件上不要使用运算函数，以免索引失效\n 10. 多列索引还有最左前缀的特性，即索引的第一个字段sex要出现在where条件中\n 11. 当where后的条件联合起来查询结果区分度高时推荐使用联合索引\n\n>  MYSQ逻辑处理步骤如下图\n\n![在这里插入图片描述](MYSQL学习笔记one\\1.png)\n","tags":["MYSQL","触发器"]},{"title":"Hello World","url":"/2019/06/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n"},{"title":"springboot登陆页面图片验证码简单的web项目","url":"/2019/04/02/springboot登陆页面图片验证码简单的web项目/","content":"\n# 写在前面\n前段时间大家都说最近大环境不好，好多公司在裁员，换工作的话不推荐轻易的裸辞，但是我想说的是我所在的公司好流弊，有做不完的业务需求，还有就是招不完的人......\n最近我也是比较繁忙，但是还是要抽一点时间来进行自我复盘和记录，最近也写一个简单的小功能，就是登陆界面的图片验证码功能\n>环境：Tomcat9、Jdk1.8\n>\n## 1 生成验证码的工具类\n\n```javascript\npublic class RandomValidateCodeUtil {\n\n\n    public static final String RANDOMCODEKEY= \"RANDOMVALIDATECODEKEY\";//放到session中的key\n    private String randString = \"0123456789\";//随机产生只有数字的字符串 private String\n    //private String randString = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";//随机产生只有字母的字符串\n    //private String randString = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";//随机产生数字与字母组合的字符串\n    private int width = 95;// 图片宽\n    private int height = 25;// 图片高\n    private int lineSize = 40;// 干扰线数量\n    private int stringNum = 4;// 随机产生字符数量\n\n    private static final Logger logger = LoggerFactory.getLogger(RandomValidateCodeUtil.class);\n\n    private Random random = new Random();\n\n    /**\n     * 获得字体\n     */\n    private Font getFont() {\n        return new Font(\"Fixedsys\", Font.CENTER_BASELINE, 18);\n    }\n\n    /**\n     * 获得颜色\n     */\n    private Color getRandColor(int fc, int bc) {\n        if (fc > 255)\n            fc = 255;\n        if (bc > 255)\n            bc = 255;\n        int r = fc + random.nextInt(bc - fc - 16);\n        int g = fc + random.nextInt(bc - fc - 14);\n        int b = fc + random.nextInt(bc - fc - 18);\n        return new Color(r, g, b);\n    }\n\n    /**\n     * 生成随机图片\n     */\n    public void getRandcode(HttpServletRequest request, HttpServletResponse response) {\n        HttpSession session = request.getSession();\n        // BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类\n        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR);\n        Graphics g = image.getGraphics();// 产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作\n        g.fillRect(0, 0, width, height);//图片大小\n        g.setFont(new Font(\"Times New Roman\", Font.ROMAN_BASELINE, 18));//字体大小\n        g.setColor(getRandColor(110, 133));//字体颜色\n        // 绘制干扰线\n        for (int i = 0; i <= lineSize; i++) {\n            drowLine(g);\n        }\n        // 绘制随机字符\n        String randomString = \"\";\n        for (int i = 1; i <= stringNum; i++) {\n            randomString = drowString(g, randomString, i);\n        }\n        logger.info(randomString);\n        //将生成的随机字符串保存到session中\n        session.removeAttribute(RANDOMCODEKEY);\n        session.setAttribute(RANDOMCODEKEY, randomString);\n        g.dispose();\n        try {\n            // 将内存中的图片通过流动形式输出到客户端\n            ImageIO.write(image, \"JPEG\", response.getOutputStream());\n        } catch (Exception e) {\n            logger.error(\"将内存中的图片通过流动形式输出到客户端失败>>>>   \", e);\n        }\n\n    }\n\n    /**\n     * 绘制字符串\n     */\n    private String drowString(Graphics g, String randomString, int i) {\n        g.setFont(getFont());\n        g.setColor(new Color(random.nextInt(101), random.nextInt(111), random\n                .nextInt(121)));\n        String rand = String.valueOf(getRandomString(random.nextInt(randString\n                .length())));\n        randomString += rand;\n        g.translate(random.nextInt(3), random.nextInt(3));\n        g.drawString(rand, 13 * i, 16);\n        return randomString;\n    }\n\n    /**\n     * 绘制干扰线\n     */\n    private void drowLine(Graphics g) {\n        int x = random.nextInt(width);\n        int y = random.nextInt(height);\n        int xl = random.nextInt(13);\n        int yl = random.nextInt(15);\n        g.drawLine(x, y, x + xl, y + yl);\n    }\n\n    /**\n     * 获取随机的字符\n     */\n    public String getRandomString(int num) {\n        return String.valueOf(randString.charAt(num));\n    }\n}\n\n```\n这个类不用动，可以直接拿来用\n## 2 页面代码\n```javascript\n\n<!--html/bady代码-->\n\n<div >\n    <div >\n        <div >\n            <input  type=\"tel\" id=\"verify_input\" placeholder=\"请输入验证码\" maxlength=\"4\">\n        </div>\n    </div>\n    <div >\n        <a href=\"javascript:void(0);\" title=\"点击更换验证码\">\n            <img id=\"imgVerify\" src=\"login/getVerify\" alt=\"更换验证码\" height=\"36\" width=\"170\" onclick=\"getVerify(this);\">\n        </a>\n    </div>\n    <input type=\"button\" onclick=\"aVerify()\" value=\"提交\">\n</div>\n</body>\n\n<!--js中的代码-->\n<script type=\"text/javascript\" src=\"./js/jquery.min.js\"></script>\n<script>\n\n    //获取验证码\n    /*function getVerify(obj){\n        obj.src =  \"login/getVerify?\"+Math.random();//原生js方式\n    }*/\n\t\n\t//获取验证码\n    function getVerify() {\n        // $(\"#imgCode\").on(\"click\", function() {\n        $(\"#imgVerify\").attr(\"src\", 'login/getVerify?' + Math.random());//jquery方式\n        // });\n    }\n\n    function aVerify(){\n        var value =$(\"#verify_input\").val();\n        // alert(value);\n        $.ajax({\n            async: false,\n            type: 'post',\n            url: 'login/checkVerify',\n            dataType: \"json\",\n            data: {\n                verifyInput: value\n            },\n            success: function (result) {\n                if (result) {\n                    alert(\"success!\");\n                } else {\n                    alert(\"failed!\");\n                }\n                // window.location.reload();\n                getVerify();\n            }\n        });\n    }\n</script>\n```\n\n> 注意：这里有2种获取验证码图片的方法\n## 3 获取code和验证code的类\n```java\n@RestController\n@RequestMapping(\"/login\")\npublic class Picverifyaction {\n    private final static Logger logger = LoggerFactory.getLogger(Picverifyaction.class);\n\n    /**\n     * 生成验证码\n     */\n    @RequestMapping(value = \"/getVerify\")\n    public void getVerify(HttpServletRequest request, HttpServletResponse response) {\n        try {\n            response.setContentType(\"image/jpeg\");//设置相应类型,告诉浏览器输出的内容为图片\n            response.setHeader(\"Pragma\", \"No-cache\");//设置响应头信息，告诉浏览器不要缓存此内容\n            response.setHeader(\"Cache-Control\", \"no-cache\");\n            response.setDateHeader(\"Expire\", 0);\n            RandomValidateCodeUtil randomValidateCode = new RandomValidateCodeUtil();\n            randomValidateCode.getRandcode(request, response);//输出验证码图片方法\n        } catch (Exception e) {\n            logger.error(\"获取验证码失败>>>>   \", e);\n        }\n    }\n\n    /**\n     * 校验验证码\n     */\n    @RequestMapping(value = \"/checkVerify\", method = RequestMethod.POST,headers = \"Accept=application/json\")\n    public boolean checkVerify(@RequestParam String verifyInput, HttpSession session) {\n        try{\n            //从session中获取随机数\n            String inputStr = verifyInput;\n            String random = (String) session.getAttribute(\"RANDOMVALIDATECODEKEY\");\n            if (random == null) {\n                return false;\n            }\n            if (random.equals(inputStr)) {\n                return true;\n            } else {\n                return false;\n            }\n        }catch (Exception e){\n            logger.error(\"验证码校验失败\", e);\n            return false;\n        }\n    }\n\n}\n```\n## 4 效果图镇楼\n![](springboot登陆页面图片验证码简单的web项目/Snipaste_2019-04-02_17-10-15.png)\n## 5 源码\n当然上面代码只是核心部分，如果有问题可去github自行下载 [charmsongo](https://github.com/charmsongo/pictureverifycode)\n>如果有什么更好的方法欢迎留言\n\n","tags":["Java","Tomcat","JS","验证"]},{"title":"JavaWeb 项目与系统时间相差 8 个小时的问题","url":"/2019/03/31/JavaWeb-项目与系统时间相差-8-个小时的问题/","content":"\n# 写在前面\n\n今天记录分享一个排查部署到 Linux 上的 web 项目执行的时间和本地系统时间相差 8 小时的问题\n>环境：redhat 6.5\n>考虑有规律的时间差可能和时区不同有关\n\n## 1 查看 Linux 系统时间和时区\n```javascript\n[root@localhost ~]# date\n2019年 03月 31日 星期日 16:00:32 CST\n[root@localhost ~]# date -R\nSun, 31 Mar 2019 16:00:44 +0800\n[root@localhost ~]# date +\"%Z %z\"\nCST +0800\n```\n从这里可以确定，系统的时间和时区正常（北京时间，也就是东八区），时区详情请看[这里](https://blog.csdn.net/ensoo/article/details/7527615)\n## 2 查看 jvm 时间和时区\n\n2.1 先在 Linux 上某个目录执行 javac ，看 javac 命令是否可用,出现如下显示就可以（中间部分已省略）\n```javascript\n[root@localhost test]# javac\n用法: javac <options> <source files>\n其中, 可能的选项包括:\n  -g                         生成所有调试信息\n  -g:none                    不生成任何调试信息\n  -g:{lines,vars,source}     只生成某些调试信息\n  ......\n  -X                         输出非标准选项的提要\n  -J<标记>                     直接将 <标记> 传递给运行时系统\n  -Werror                    出现警告时终止编译\n  @<文件名>                     从文件读取选项和文件名\n```\n\n2.2  编写测试程序\n```java\nimport java.util.TimeZone;\nimport java.util.Date;\n\npublic class time {\n    public static void main(String[] args) {\n        System.out.println(\"当前时间：\"+new Date());\n        System.out.println(\"当前默认时区：\"+TimeZone.getDefault());\n    }\n}\n```\n2.3 编译执行\n\n```java\n[root@localhost test]# javac time.java \n[root@localhost test]# ll\n总用量 8\n-rw-r--r-- 1 root root 780 3月  31 16:02 time.class\n-rw-r--r-- 1 root root 239 3月  31 16:00 time.java\n[root@localhost test]# java time\n当前时间：Sun Mar 31 08:02:34 CTM 2019\n当前默认时区：sun.util.calendar.ZoneInfo[id=\"GTM\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null]\n```\n这里有导其他的包，如果以上命令不好使，则使用如下命令 （中间的点 . 是当前目录的意思）\n```java\n[root@localhost test]# javac -d . time.java\n[root@localhost test]# ll\n总用量 8\n-rw-r--r-- 1 root root 780 3月  31 16:03 time.class\n-rw-r--r-- 1 root root 239 3月  31 11:00 time.java\n[root@localhost test]# java -cp . time\n当前时间：Sun Mar 31 08:02:40 CST 2019\n当前默认时区：sun.util.calendar.ZoneInfo[id=\"GTM\",offset=28800000,dstSavings=0,useDaylight=false,transitions=29,lastRule=null]\n```\n> 这里显然 jvm 的时间比系统的时间早了 8 个小时，且是格林威治的时区，所以这里修改 jvm 的时区即可，这里说下，网上查询说 jvm 的时区默认读取的是硬件时区，目录为 /etc/sysconfig/clock （[详情](http://rashost.com/blog/centos-timezone-configure)），查看如下\n\n```java\n[root@localhost test]# cat /etc/sysconfig/clock \nZONE=\"Asia/Shanghai\"\n```\n\n> 与网上对比，这里没有下面这两行\n```java\nUTC=false\nARC=false\n```\n> 这里看有人说是没有设置 UTC=false 导致的问题，查看资料说 UTC 指定 BIOS 中保存的时间是否是 GMT/UTC 时间，true 表示 BIOS 里面保存的时间是 UTC 时间，false 表示 BIOS 里面保存的时间是本地时间。\n> 加上后有的机器还是不好使，如果是在 tomcat 下运行的项目，那就重启 tomcat 即可。\n\n如果还不好使，还有修改 tomcat 配置文件的方法，欢迎参考之前的文章：[Tomcat修改日期的时区](https://blog.csdn.net/qq_29175301/article/details/81326823)\n\n>现在问题基本已解决，以上有些内容是客户现场出现的，所以现在记录时也是凭笔记和记忆回忆的，如有偏差也请不吝赐教。\n\n文章参考：https://blog.csdn.net/liqinghuiyx/article/details/53333284","tags":["Linux","Jvm","Java","时区","时间"]},{"title":"亦大亦小如你--MySQL","url":"/2019/03/09/亦大亦小如你-MySQL/","content":"\n# 写在前面\nMySQL 是个神奇的关系型数据库，真心感觉牛逼，因为做的项目比较杂，之前也碰到过 Oracle 数据库，给我的印象是 Oracle 很臃肿繁琐，配置多，如果是小项目用它的话感觉就像是杀鸡用牛刀，大材小用。但是也不是说Mysql不能用于大项目，MySQL 开元免费，是现在关系型数据库的主流产品，网上相应的文档和问题解决方案也会很多，意思就是比如菜鸟如我碰到了Mysql出的问题，网上基本上很全。\n>系统环境 Debain 7\n>Mysql  5.6\n\n\n## 1.MySQL 简单操作命令\n```javascript\n//1.登录mysql，括号中的为可选项，$（包括$）后面为实际数据，-D是指定数据库登录\nmysql (-h$host) (-P$port) -u$user -p$pwd (-D$dbname)  //地址 端口 账号 密码 数据库名\n\n//2.删除、创建数据库\ndrop database dbname; //删除数据库\ncreate database dbname charset utf8   //创建数据库\n\n//3.删除、创建数据库表\ndrop table tablename;//删除表\ncreate table tablename(id int, name varchar(80)); //创建表\n\n//4.表操作\nshow triggers\\g / show triggers; //查看触发器\nshow variables like 'character_set_database'; //查看库编码\ndesc tablename; //查看表结构\nselect current_date(); //查看表创建时间\n\n//5.导入sql文件\nuse dbname;source /dbname.sql; //执行 sql 文件\n\n//6.当前的连接情况\nselect current_user(); //查看当前登录账号\nshow processlist; //查看当前进程\nshow full processlist;//查看当前全部进程\nselect user,host,Super_priv from mysql.user; //查看所有可连接用户、地址和权限信息\n（Super_priv 用户有super权限才可以导入数据）\ngrant all privileges on *.* to root@'%' identified by 'root' with grant option;flush privileges; //给root用户远程登录的所有权限\n```\n\n## 2.自动导入sql文件\t\n### 2.1 shell操作\n```javascript\n#创建 createDb.sh，内容如下：\n\n#!/bin/bash\n#通过 shell 自动初始化数据库和表结构\nhost=$1 #地址\nport=$2 #端口\nuser=$3 #账号\npwd=$4 #密码\ndbname=$5 #数据库名\npath=$6 #sql 文件路径\n\nmysql -h$host -P$port -u$user -p$pwd <<EOF\n\ndrop database if exists $dbname;create database $dbname charset utf8;\n\nuse $dbname;\n\nsource $path\n\nCOMMIT;\nEOF\n\n#查看 shell 的执行过程命令\nsh -x ./shell //查看 shell 执行过程\n```\n### 2.2 expect操作\n```javascript\n#!/usr/bin/expect -f\n\nset timeout 10\nset host [lindex $argv 0]\nset port [lindex $argv 1]\nset user [lindex $argv 2]\nset pwd [lindex $argv 3]\nset dbname [lindex $argv 4]\nset path [lindex $argv 5]\nset cset [lindex $argv 6] #字符编码\n\nspawn mysql -h$host -P$port -u$user -p\nexpect \"Enter password: \"\nsend \"$pwd\\r\"\n\nexpect \"mysql> \"\nsend \"drop database if exists $dbname;create database $dbname charset $cset;\\r\"\n\nexpect \"mysql> \"\nsend \"use $dbname;\\r\"\n\nexpect \"mysql> \"\nsend \"source $path;\\r\"\n\nexpect \"mysql> \"\nsend \"exit\\r\"\n\ninteract\n```\n> 回头研究再更新操作，有哪里写的不对的也请不吝赐教\n","tags":["CentOS","Linux","MySQL","Shell","Expect"]},{"title":"LInux下如何挂载光盘找rpm包？","url":"/2019/03/03/LInux下如何挂载光盘找rpm包？/","content":"\n# 写在前面\nLinux 使用有时需要安装软件，当然可以通过 yum 命令来在线安装，也可以通过下载好的 rpm 包来进行安装，但是 rpm 安装需要自己来找安装软件所依赖的 rpm 包。今天就来尝试操作下\n>系统环境 CentOS 7.5\n>[root@localhost /]# cat /etc/redhat-release \nCentOS Linux release 7.5.1804 (Core)\n\n## 1.找到光盘的全路径\n```javascript\n[root@localhost /]# ls -l /dev | grep cdrom\nlrwxrwxrwx 1 root root           3 3月   3 09:32 cdrom -> sr0\ncrw-rw---- 1 root cdrom    21,   1 3月   3 09:32 sg1\nbrw-rw---- 1 root cdrom    11,   0 3月   3 09:32 sr0\n```\n这个命令知道了光盘的名字叫：cdrom，那光盘的路径就是 /dev/cdrom\n## 2.挂载光盘\n```javascript\n[root@localhost /]# mount /dev/cdrom /mnt\nmount: /dev/sr0 写保护，将以只读方式挂载\n```\n\n> 这个命令是把目录 /dev/cdrom 的内容加载到了目录 /mnt 下，也就是说目录 /mnt 下可以访问目录 /dev/cdrom 中的内容了，出现如下内容就挂载成功了\n\n```javascript\n[root@localhost /]# cd /mnt/\n[root@localhost mnt]# ls\nCentOS_BuildTag  EULA images LiveOS  repodata  RPM-GPG-KEY-CentOS-Testing-77EFI GPL   isolinux  Packages  RPM-GPG-KEY-CentOS-7  TRANS.TBL\n```\n\n## 3.拷贝目标rpm包\n\n> 进入刚才的目录 Packages ，然后找到目标rpm包，这里以「telnet 客户端」为例\n\n```java\n[root@localhost mnt]# cd Packages/\n[root@localhost Packages]# ls -l | grep telnet\n-rw-rw-r-- 2 root root    65632 8月  11 2017 telnet-0.17-64.el7.x86_64.rpm\n-rw-rw-r-- 2 root root    41804 8月  11 2017 telnet-server-0.17-64.el7.x86_64.rpm\n```\n\n这里出来 2 个，但是看名称可以明白第一个是客户端，另一个是服务端，这里选择第一个即可，然后复制到 /root 下，出现如下结果即成功\n```java\n[root@localhost Packages]# cp telnet-0.17-64.el7.x86_64.rpm /root/\n[root@localhost Packages]# ls -l /root\n总用量 72\n-rw-------. 1 root root  1569 6月   3 2018 anaconda-ks.cfg\n-rw-r--r--  1 root root 65632 3月   3 10:08 telnet-0.17-64.el7.x86_64.rpm\n-rw-r--r--. 1 root root     0 6月  30 2018 ????.txt\n```\n## 4.卸载光盘\n知道目标rpm包后，要记得卸载光盘哦！（**先切出目录 /mnt**）\n```java\n[root@localhost Packages]# cd /\n[root@localhost /]# umount /mnt/\n[root@localhost /]# ls -l /mnt/\n总用量 0\n```\n## 5.安装拷贝的rpm包\n```java\n[root@localhost /]# cd root/\n[root@localhost ~]# rpm -ivh telnet-0.17-64.el7.x86_64.rpm \n准备中...                          ################################# [100%]\n        软件包 telnet-1:0.17-64.el7.x86_64 已经安装\n[root@localhost ~]# telnet\ntelnet> \n```\n\n> 出现如上内容说明 telnet 客户端已经安装成功，是不是很简单？\n","tags":["CentOS","Linux","rpm","挂载光盘"]},{"title":"谈一谈你有多少决定是父母决定的","url":"/2019/02/07/谈一谈你有多少决定是父母决定的/","content":"![谈一谈你有多少决定是父母决定的](谈一谈你有多少决定是父母决定的/长大.jpg)\n\n你从小到大有多少决定是为自己做的，有多少是为他人决定的或者说是被他人决定的？\n\n从小被教育是要听妈妈的话，这种思想还被周董载入了音乐，你别说，听着还真好听。是 的，小孩子天生调皮，闹腾，听话的直接结果就是父母会轻松很多，而且农村长大的孩子都明白，父母为了生计会经常忙于奔波，基本没时间照顾上学后的孩子，听话这个方式看起来会让父母少很多教育的成本，但是，事实真的是这样吗？\n\n大家知道有一些病症是有潜伏期的，当然听妈妈话的这种教育方式也是有反噬的潜伏期的，它会剥夺孩子的疑问和思考事情的过程，还有 自我改变的动力，孩子长大后就会缺失基本抉择的能力。会对父母产生依赖，18岁本是成年的分界年龄，之后的事情自己完全有权利自己做决定，但是见过不少，处对象和结婚都要经过父母的决定和选择，工作不顺利，问问父母要不要离职再找，当然父母一般的回答是有工作干着就不错了。衣服也要父母来买或者是好看不好看父母说了算......\n\n我们曾经是个孩子，但终究是要长大的，父母不能陪我们一辈子，父母也终会变老，变成老小孩，也需要依靠我们来抉择，有些事情就是要自己去做决定的。第一批 90 后都已经 30 岁了，作为奔三的人了，不得不逼着自己长大，家庭主梁的接力棒我们要尝试着接过来了，该为父母承担家庭的压力了。\n\n现在感觉父母处理的一些事情不是特别好，请不要埋怨她们，她们没有错，只是父母在变老，她们替我们做了本该我们来抉择的抉择。\n\n![谈一谈你有多少决定是父母决定的](谈一谈你有多少决定是父母决定的/微信二维码.png)","tags":["成长","思想","人生"]},{"title":"迟到但重要的事","url":"/2019/01/31/迟到但重要的事/","content":"\n![迟到但重要的事](迟到但重要的事/001.jpg)\n> 好久没更文了，一来年底了公司有些项目结尾非常忙，当然这也是接口，二来自己最近不知道该写点什么，本来 2018 年阳历 12 月有份总结一直没来的及发，就趁这个机会记录下。\n\n30 号半夜醒来后，睡意全无，心里有事，就会休息不好，事实确实如此，想想这个毛病也是高考后遗症吧，思考太多，做的太少，自己知道这个道理，有时候身边就是少个可以提点自己的人，这个人最好是前辈，不然感觉我自己接受的层度不够，还要就是自己的执行力了，想做就去做。\n\n陈谷子烂芝麻扯皮完啦，说下困扰自己的事情，活这么大，总是有些事想不开，但是解不开又故步自封，不能没有一点进展，迷茫困扰着自己，25 岁了，我把人生以 10 年划分一个阶段，我预计先划分 4 个阶段，也就是到 65，我希望自己可以选一个可以持久坚持下去的一个方向，自己可以成长，自己可以获利，也可以沉淀。我想写作是这个方向，也有好多人确实鉴定了这点，但以我一个理科男的角度来说，很难，没有什么文采，感觉很伤，但是为何不先尝试呢，趁着年轻，多尝试犯错，第一个十年就是这样的机会，如果 35 ，岁之前还是没有什么成效或者好的方向的话，那么也就只能认命了，自己辛苦点，培养下一代出息吧。\n\n**我也初步拟定了几个方向：**\n\n 1. 「身体」身体是革命，人生会经历很多，无外乎健康。财富，女人和事业，如果给他们估个价，那身体拍最前是 1，其余的都是 0，如果 1 没了要那么多 0 等于没有，所以培养健康的生活方式，每天必须抽 30分钟到1小时锻炼，不是工作或重要事情，每天10点休息，早上6点起床，本身就有些薄弱，就需要重视起来。\n 2. 「自我塑造」包括形象和学识，也就是表面的和内在的，这可以双修，活的不要邋遢，勤快的，抽时间多看书，也许有些道理就突然就明白了，也会有输出的底蕴。\n 3. 「投资系统」这个是个重点，也可以说第二个阶段 45 岁以后可可否小有成就，看这个做的好不好了，学习上必须的，这个也看大环境，不过环境不好还可以盈利才是真本事。慢慢养鹅。\n 4. 「人脉关系」不管之前怎么样，从现在开始就要培养和细化朋友的圈子了，这就像投资系统一样，时间越长，它越像财富。\n 5. 「工作」虽然放后面也不是说不重要，而是初期经济来源都是这里，提高自己的核心竞争力，专业技能，初期也给自己一份保障。\n 6. 「产品思想」每个人都是产品经理，自己就是自己的产品，为别人打工和创业都一样，就是想让自己卖个好价钱，所以好好对自己，提高自己的影响力\n\n最后离过年没几天了，公司同事也都陆续回家了，也祝大家新年越来越牛逼。\n> *个人公号：charmsongo*\n\n\n\n\n","tags":["生活","感悟","随笔","目标","总结"]},{"title":"有些事并不是看到的那样","url":"/2019/01/05/有些事并不是看到的那样/","content":"![在这里插入图片描述](有些事并不是看到的那样/温暖.jpg)\n> 今天看到一句不错的话：不要因为干枯的落叶🍂而放弃整棵大树。\n\n- 有时候人眼看到的不一定是真是的，更别说带着偏见看到的，相亲时都强调说第一印象，对某事或某人有偏见这种现象大多都是第一印象惹得祸。a同学去了 H 公司上班，刚开始新鲜感充满了他的大脑，感觉公司还不错，后来慢慢的跟 b 同学聊天调侃自己在公司工作的过程中，发现自己公司真的有点 low，随后一到公司就会想到公司的不好，进而看公司领导和同事也会拿去和别的公司的领导同事做比较，感觉没有别人家的领导和同事好，情绪就会蔓延，殊不知，这都是因为开始对公司的偏见而衍生出对公司人的偏见。\n\n- 人都有缺点和优点，也许你只是拿公司的缺点去对比别人家公司的优点，结果肯定不如意，每个公司存在，肯定有存在的道理。它自身的竞争力，也算是优点，只有从内心开放开来，去深入感受，才会理清，也许 c 同事对自己的事非常热心，d 同事非常有耐心，给我讲东西从来不着急...\n\n- 每个结论都要弄清楚后再决定","tags":["生活","感悟","随笔"]},{"title":"胡乱随笔","url":"/2018/12/22/胡乱随笔/","content":"![在这里插入图片描述](胡乱随笔/往后余生.jpg)\n\n- 1.这个世界，该来的总会来，该走的也不会长留，现如今的同学还在你身边吗？小到小学，大到大学毕业，有的早已结婚生子，孩子都快打酱油了，也有大学同学在同一个城市拼搏，但是见面的机会却很少，这或许也是一种最熟悉的陌生人。\n\n- 2.现在是你满意的生活吗？你有多久没有发自内心开心的笑了，你又有多久没有为自己真正做过选择了。\n\n- 3.你还是那个听歌可以听一天，看书可以看一天，不着急不焦虑，就是这样等时间慢下去，即使看到彤红的晚霞也可以去欣喜大自然的神奇而忘记一天的时间已经消逝。\n\n- 4.麻木，呆滞，嫉妒，孤独……好像类似这些消极悲观的字眼都看上你了一样，总是想环绕你左右，即使你突破了它们的包围圈，它们也可以很快恢复原状。\n\n- 5.每次情绪不好的时候总想去感叹，调侃，但是却不知该向谁说起，也不知道该如何说出口，看修仙的小说，主人公一般会直接或间接的在困难的时候受到高人指点，但现实生活中遇到这样的贵人是可遇不可求的。\n\n- 6.想做一件事的时候，如果想的太多，衍生的束缚就会越多，越来越畏首畏尾，倒不如管他三七二十一，干就完了。\n\n- 7.年轻的时间就这么点，要学会珍惜，即使浪费，也要浪费在自己想做而没做的事情上，干的多了再去考虑如何才会有意义，干就完了。\n\n","tags":["life","态度"]},{"title":"推荐一个java操作ftp的工具类","url":"/2018/12/08/推荐一个java操作ftp的工具类/","content":"\n# 写在前面\n作为经常使用电脑整理文件的童鞋，应该都使用过从ftp服务器上传下载文件，那么今天就了解下如何通过java程序操作ftp服务的文件\n>首先你要知道ftp的ip，路径，端口，有操作权限的账号和密码\n\n## 1 导入jar包\n\n```javascript\n commons-net-3.6.jar\n```\n这个jar包用来设置编码，经过测试，不加也可用\n## 2 工具类中主要方法\n### 2.1 登陆ftp\n```javascript\n\t/**\n\t * 验证登录\n\t * @param ip\n\t * @param port\n\t * @param name\n\t * @param pwd\n\t * @return\n\t */\n\tpublic boolean login(String ip,int port, String name, String pwd) {\n\t\ttry {\n\t\t\tftp = new FTPClient();\n\t\t\tftp.connect(ip, port);\n\t\t\tSystem.out.println(ftp.login(name, pwd));\n\t\t\tif(!ftp.login(name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tftp.setCharset(Charset.forName(\"UTF-8\"));\n\t\t\tftp.setControlEncoding(\"UTF-8\");\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n```\n\n> 注意：获取远程文件目录，上传和下载方法基于登陆方法\n### 2.2 获取远程文件目录\n```java\n\t/**\n\t * 获取ftp某一文件（路径）下的文件名字,用于查看文件列表\n\t * @param ip\n\t * @param port\n\t * @param name\n\t * @param pwd\n\t * @param remotedir 远程地址目录\n\t * @return\n\t */\n    public boolean getFilesName(String ip,int port, String name, String pwd, String remotedir) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //获取ftp里面，指定文件夹 里面的文件名字，存入数组中\n            FTPFile[] files = ftp.listFiles(remotedir);\n            //打印出ftp里面，指定文件夹 里面的文件名字\n            for (int i = 0; i < files.length; i++) {\n                System.out.println(files[i].getName());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n        return true;\n    }\n```\n### 2.3 上传文件\n```java\n\t/**\n     * 上传文件 方法一\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean putFileOne(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //将本地的 localpath 文件上传到ftp的根目录文件夹下面，并重命名为 remotepath中的名字\n        \t return ftp.storeFile(remotepath, new FileInputStream(new File(localpath)));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n    }\n    \n    /**\n     * 上传文件的第二种方法，优化了传输速度\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean putFileTwo(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            os = ftp.storeFileStream(remotepath);\n            fis = new FileInputStream(new File(localpath));\n            byte[] b = new byte[1024];\n            int len = 0;\n            while ((len = fis.read(b)) != -1) {\n                os.write(b,0,len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally {\n        \tthis.close();\n\t\t}\n        return true;\n    }\n```\n### 2.4 下载文件\n\n```java\n\t/**\n     * 下载文件 方法一\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath 本地文件路径\n     * @return\n     */\n    public boolean getFileOne(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n        try {\n        \tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n            //将ftp资源中 remotepath 文件下载到本地目录文件夹下面，并重命名为 localpath 中的名字\n        \treturn ftp.retrieveFile(remotepath, new FileOutputStream(new File(localpath)));\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }finally{\n        \tthis.close();\n        }\n    }\n\t\n    /**\n     * 下载文件的第二种方法，优化了传输速度\n     * @param ip\n     * @param port\n     * @param name\n     * @param pwd\n     * @param remotepath 远程地址文件路径\n     * @param localpath  本地文件路径\n     * @return\n     */\n\tpublic boolean getFileTwo(String ip,int port, String name, String pwd,String remotepath,String localpath) {\n\t\ttry {\n\t\t\tif(!login(ip, port, name, pwd)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis = ftp.retrieveFileStream(remotepath);\n\t\t\tfos = new FileOutputStream(new File(localpath));\n\t\t\tbyte[] b = new byte[1024];\n\t\t\tint len = 0;\n\t\t\twhile ((len = is.read(b)) != -1) {\n\t\t\t\tfos.write(b,0,len);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn false;\n\t\t}finally {\n\t\t\tthis.close();\n\t\t}\n\t\treturn true;\n\t}\n```\n## 3 源码\n当然上面代码只是重要的部分，如果有问题可去github自行下载 [charmsongo](https://github.com/charmsongo/ftptest)\n>如果有什么更好的方法欢迎留言","tags":["java","ftp"]},{"title":"application.properties数据库敏感信息加密这么简单？","url":"/2018/12/01/application-properties数据库敏感信息加密这么简单？/","content":"\n# 写在前面\n俗话说：”顾客是上帝“，身为程序员的我有时会直接对接客户方提出的需求，毕竟我处在提供服务的一方，所以我也会尽量的满足临时的要求。前些天就有了一个满足漏洞检测的需求，想要把数据库的明文敏感信息加密，其实也就是密码加密，所以也就有了这篇文章，我的项目是springboot结构，修改其实也挺简单，废话少说，上代码。\n\n>这里使用的是 jasypt，而它是一个java实现的安全框架\n\n## 1.Maven的pom.xml依赖\n```javascript\n <dependency>\n     <groupId>com.github.ulisesbocchio</groupId>\n     <artifactId>jasypt-spring-boot-starter</artifactId>\n     <version>1.8</version>\n </dependency>\n```\n\n## 2.通过测试类验证加密加密\n测试类如下\n```javascript\nimport org.jasypt.encryption.pbe.StandardPBEStringEncryptor;\nimport org.jasypt.encryption.pbe.config.EnvironmentPBEConfig;\n\n/**\n * Created By charmsongo 21:04 2018/11/30\n */\npublic class CryptorTest {\n\n    /**\n     * 加密方法\n     * @param plainText 需加密文本\n     */\n    public static void testEncrypt(String plainText) {\n        StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor();\n        EnvironmentPBEConfig config = new EnvironmentPBEConfig();\n\n        // 加密的算法，这个算法是默认的\n        config.setAlgorithm(\"PBEWithMD5AndDES\");\n        //加密的密钥，自定义\n        config.setPassword(\"CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7\");\n        standardPBEStringEncryptor.setConfig(config);\n        String encryptedText = standardPBEStringEncryptor.encrypt(plainText);\n        System.out.println(encryptedText);\n    }\n\n    /**\n     * 解密方法\n     * @param encryptedText 需解密文本\n     */\n    public static void testDecrypt(String encryptedText) {\n        StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor();\n        EnvironmentPBEConfig config = new EnvironmentPBEConfig();\n\n        // 解密的算法，需同加密算法相同\n        config.setAlgorithm(\"PBEWithMD5AndDES\");\n        //解密的密钥，需同加密密钥相同\n        config.setPassword(\"CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7\");\n        standardPBEStringEncryptor.setConfig(config);\n        String plainText = standardPBEStringEncryptor.decrypt(encryptedText);\n        System.out.println(plainText);\n    }\n\n    public static void main(String[] args){\n        testEncrypt(\"root\");\n        testDecrypt(\"TU1NovjRHGyjp7cSc6v0sQ==\");\n    }\n}\n```\n**运行main方法结果如下**\n```javascript\nTU1NovjRHGyjp7cSc6v0sQ==\nroot\n```\n\n## 3.application.properties中配置修改\n```javascript\n##mysql-----修改前配置\nspring.datasource.url=jdbc:mysql://192.168.2.105/mysql?characterEncoding=utf8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n\n##mysql-----修后前配置\njasypt.encryptor.password=CSEbfYkitulv73I2p0mXI50JMXoaxZTKJ7#引入密钥\nspring.datasource.url=jdbc:mysql://192.168.2.105/mysql?characterEncoding=utf8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=ENC(TU1NovjRHGyjp7cSc6v0sQ==)\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n```\n\n> 使用 jasypt 加密数据库敏感信息的任务现在就可以交工了，但是看完您会发现，这样也不是特别安全的，确实。。。所以您有什么更好的加密方法欢迎留言","tags":["java","mysql","jasypt","application.properties","springboot"]},{"title":"记录下死磕过的一个坑","url":"/2018/11/10/记录下死磕过的一个坑/","content":"\n# 写在前面\n最近公司项目提了个很正常的需求，为什么说是很正常的需求呢，保守点说，大多数的项目都会默认有这样的功能，那就是tomcat指定404页面，具体情况请听我再啰嗦啰嗦。有这么一场景，有人想攻击一家的项目，但是攻击前需要了解该公司项目的具体组成部分才可以进行真正的攻击吧，但是我也不知道该项目都有哪些目录？目录下有哪些文件？可以用笨方法就是去试，用一个大概常用的路径去访问该项目地址，比如ip/项目名/xxx,不存在的路径会看到默认的404页面会显示tomcat的版本和其它的一些信息，敏感信息会暴露，有点危险，所以我公司不想让别人看到这些，那就需要指定一个页面，找不到的路径都要转发这个页面。\n## 1.修改web.xml\n\n修改的文件路径如下，只要放在tomcat下的都走这个配置\n```javascript\n/*/*/tomcat/conf/web.xml\n```\n在web.xml文件最后添加内容如下，error-code是浏览器状态码为404就转发404.jsp页面，这里需要注意一下，我就载在了这里，location是当前运行项目的下的路径，通俗点讲就是，一个项目名为songo，那么404.jsp页面就要放在songo项目下，对应的路径就是/songo/404.jsp,其实我也不知道为什么是这样设置，但是就是这样好使了\n```javascript\n    <error-page>\n    <error-code>404</error-code>\n    <location>/404.jsp</location>\n    </error-page>\n</web-app>\n```\n**这样的话就有个问题，如果tomcat下有多个项目，那每个项目根下都要放一个相同的404.jsp页面，如果您有什么更好的办法欢迎留言**\n## 2.404页面注意问题\n404.jsp需要添加2行内容，如下\n```javascript\n<%@ page language=\"java\" contentType=\"text/html; charset=gbk\" pageEncoding=\"gbk\" isErrorPage=\"true\"%>\n<%response.setStatus(HttpServletResponse.SC_OK);%>\n```\n**这2行主要是告诉浏览器访问服务器不存在的资源跳转的错误处理页面，但是返回正常的状态码，并且正常显示页面内容**\n另外，具体页面请到 github 自行[下载](https://github.com/charmsongo/404page)\n\n\n> 说在最后，如果有哪里有问题或写的不对的，请留言，我会尽量在第一时间给您答复\n","tags":["java","tomcat","web.xml","404"]},{"title":"ORACLE如何一次性修改用户连接数？","url":"/2018/11/08/ORACLE如何一次性修改用户连接数？/","content":"\n# oracle连接数详解\noracle连接数默认是150，当同一时间连接数大于这个数的时候就会报错，现在的解决办法为增大oracle的连接数，从150改为1500，操作如下\n## 1.修改前问题解决\n如果已经报超过连接数错误后的话，是登录不上oracle的，所以需要用命令 lsof -i:1521 查看，所有占用这个端口的进程，然后用 kill -9 PID 杀死这些进程，有可能会很多，不想一个一个杀死可以百度谷歌方法 \n\n## 2.登录oracle\n```javascript\n#切换到oracle，再登录\nsu - oracle\nsqlplus / as sysdba\n```\n## 3.查询连接数，并修改\n### 3.1使用命令 show parameter processes;\n```javascript\nSQL> show parameter processes;\nNAME                                 TYPE        VALUE\n------------------------------------ ----------- ------------------------------\naq_tm_processes                      integer     1\ndb_writer_processes                  integer     1\ngcs_server_processes                 integer     0\nglobal_txn_processes                 integer     1\njob_queue_processes                  integer     1000\nlog_archive_max_processes            integer     4\nprocesses                            integer     150\n```\n最后一行为连接数150\n### 3.2修改前需先创建 spfile 并重启 oracle 服务\n```javascript\nSQL> create spfile from pfile;\nFile created.\n\n#关闭 oracle 服务\nSQL> shutdown immediate;\nDatabase closed.\nDatabase dismounted.\nORACLE instance shut down.\n\n#启动oracle服务\nSQL> startup\nORACLE instance started.\nTotal System Global Area  835104768 bytes\nFixed Size               2257840 bytes\nVariable Size          541068368 bytes\nDatabase Buffers      289406976 bytes\nRedo Buffers      2371584 bytes\nDatabase mounted.\nDatabase opened.\n```\n### 3.3修改连接数为1500\n```javascript\nSQL> alter system set processes=1500 scope = spfile;\nSystem altered.\n\n#oracle操作要养成提交的习惯\nSQL> commit;\nCommit complete.\n\nSQL> shutdown immediate;\nDatabase closed.\nDatabase dismounted.\nORACLE instance shut down.\n\nSQL> startup\nORACLE instance started.\nTotal System Global Area  835104768 bytes\nFixed Size               2257840 bytes\nVariable Size          541068368 bytes\nDatabase Buffers      289406976 bytes\nRedo Buffers      2371584 bytes\nDatabase mounted.\nDatabase opened.\n```\n### 3.4最后验证连接数是否修改成功\n```javascript\nSQL> show parameter processes;\nNAME                                 TYPE        VALUE\n------------------------------------ ----------- ------------------------------\naq_tm_processes                      integer     1\ndb_writer_processes                  integer     1\ngcs_server_processes                 integer     0\nglobal_txn_processes                 integer     1\njob_queue_processes                  integer     1000\nlog_archive_max_processes            integer     4\nprocesses                            integer     1500\n```\n已改为1500,说明修改成功，现在可以多人痛快的连接登录oracle了\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["linux","oracle"]},{"title":"本机自定义域名映射IP","url":"/2018/11/07/本机自定义域名映射IP/","content":"\n# wins和linux设置\n其实设置很简单，修改 hosts 文件就可以了，下面详细介绍\n## 1.wins修改hosts文件\n路径如下\n```javascript\nC:\\Windows\\System32\\drivers\\etc\\hosts\n```\n打开文件在最后添加如下内容，保存即可即时生效\n```javascript\n192.168.2.1 charmsongo.com\n```\n最可能遇到的问题就是修改后保存问题了，可以参考 [链接](https://www.jb51.net/diannaojichu/133538.html)\n\n## 2.linux修改hosts文件\n路径如下\n```javascript\n/etc/hosts\n```\n使用命令「vi /etc/hosts」,同样在最后添加如下内容,然后保存即可\n```javascript\n192.168.2.1 charmsongo.com\n```\n## 3.访问方式\n访问方式的改变就更简单了，把原来 URL 中的 IP 换成改的域名即可，这里以wins上为例，如下\n```java\n#修改前url\nhttps://192.168.2.1\n\n#修改后url\nhttps://charmsongo.com/\n```\n\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["域名","IP"]},{"title":"java中文件如何加密压缩?","url":"/2018/10/27/java中文件如何加密压缩/","content":"\n# 文件加密压缩\n在现如今已经可以实现大部分功能的互联网需求中，安全成为了需要的非必需品，工作需求中会遇到对导出的 excel 报表 做加密压缩的问题，今天有时间总结一下，我这里简单列举功能代码，连带其它代码文末会一并给出。\n## 1.单个文件加密压缩\n单个文件加密方法，需传输 3 个参数：被压缩源文件，压缩目标文件和加密密钥，如下\n```javascript\n\t/**\n\t * @Title: encrypt_zip \n     * @Description:将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param src_file 待压缩文件路径\n\t * @param dst_file zip路径+文件名 \n\t * @param encode 加密密码  \n\t * @return \n\t */\n\tpublic static void encrypt_zip(String src_file, String dst_file, String encode) {\n\t\tFile file = new File(src_file);\n\n\t\tZipParameters parameters = new ZipParameters();\n\t\tparameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\tparameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); // 压缩级别\n\n\t\tparameters.setEncryptFiles(true);\n\t\tparameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\tparameters.setPassword(encode.toCharArray());//设置密码\n\n\t\ttry {\n\t\t\tZipFile zipFile = new ZipFile(dst_file);\n\t\t\tzipFile.setFileNameCharset(\"gbk\");\n\t\t\tzipFile.addFile(file, parameters);\n\n\t\t} catch (ZipException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n```\n## 2.多文件加密压缩\n\t\n多文件加密压缩和单文件类似，但是，这个方法包含上面的方法，甚至功能上可以替换上面方法，具体看下 code\n\n\n```javascript\n\t/**\n\t * @Title: zipFilesAndEncrypt \n     * @Description: 将指定路径下的文件压缩至指定zip文件，并以指定密码加密,若密码为空，则不进行加密保护 \n\t * @param srcFileName 待压缩文件路径 或 文件夹路径\n\t * @param zipFileName zip路径+文件名 \n\t * @param password 加密密码  \n\t * @return \n\t */\n    public static void zipFilesAndEncrypt(String srcFileName,String zipFileName,String password){  \n    \t\n\t    if(StrTool.is_empty(srcFileName) || StrTool.is_empty(zipFileName)){  \n\t    \tSystem.out.println(\"请求的压缩路径或者文件名有误\");\n\t    \treturn;\n\t    }  \n\t    try {  \n\t\t    ZipParameters parameters = new ZipParameters();  \n\t\t    parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);//压缩方式\n\t\t    parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL);//压缩级别\n\t\t    if(!StrTool.is_empty(password)){  \n\t\t    \tparameters.setEncryptFiles(true);     \n\t\t\t    parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_STANDARD);//加密方式\n\t\t\t    parameters.setPassword(password);  \n\t\t    }  \n\t\t    \n\t\t    ArrayList<File> filesToAdd=getFiles(srcFileName);\n\t\t    \n\t\t    ZipFile zipFile = new ZipFile(zipFileName); \n\t\t    zipFile.setFileNameCharset(\"gbk\");\n\t\t    zipFile.addFiles(filesToAdd, parameters); \n\t    } catch (ZipException e) {  \n\t    \tSystem.out.println(\"文件压缩出错\");\n\t    \te.printStackTrace();\n\t    } \n\t}\n    \n    //通过路径获取压缩文件集合\n    private static ArrayList<File> getFiles(String srcFileName){\n    \tArrayList<File> filesToAdd = new ArrayList<File>();\n\t    File file=new File(srcFileName);\n\t    File[] files = new File[0]; \n\t    if(file.isDirectory()){\n\t    \tfiles = file.listFiles();\n\t    \tfor(int i=0;i<files.length;i++){\n\t    \t\tif(files[i].getName().endsWith(\".xls\")){//xls结尾的excel添加压缩集合\n\t    \t\t\tfilesToAdd.add(new File(files[i].getPath()));\n\t\t\t    \tSystem.out.println(\"文件：\"+files[i].getPath());\n\t    \t\t}\n\t    \t}\n\t    } else {\n\t\t\tfilesToAdd.add(new File(file.getPath()));\n\t\t}\n\t    \n\t    return filesToAdd;\n    }\n```\n\n\n具体代码请关注个人公众号【charmsongo】回复[zip]\n\n> 说在最后，如果有什么问题，请留言，我会尽量在第一时间给您答复\n","tags":["java","加密","压缩"]},{"title":"JDK版本不同引发的https请求证书问题","url":"/2018/10/27/JDK版本不同引发的https请求证书问题/","content":"# 问题解决\n## 问题描述\n首先，服务器上跑着一个接口工程，环境是jdk8，为https请求（证书认证，但这里绕过了证书）；客户端通过https调用接口，环境是jdk7，请求时报如下错：\n```java\njavax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\n```\n## 问题分析\n\t\n这个问题出现的原因是因为开发时，我客户端用的jdk8测试，没有出现问题，然后客户那是jdk7，所以出现了这个问题，这是由于客户端与服务器所使用的SSL/TLS版本不一致。服务器使用的TLS版本高，而客户端支持的TLS版本低。**Java 8默认支持TLSv1.2版本**。\n\n## 解决过程\n**这里有两种解决办法**\n\n 1. 客户端升级为jdk8(让客户改不怎么现实，这种方法先pass)\n 2. 构造证书new SSLConnectionSocketFactory对象时加上两个属性\n \n\n *这里说下第二种解决方法，下面 SSLConnectionSocketFactory 上的注释* \n \n  get请求\n  \n```java\n/**\n * get请求\n * @param url\n * @param timeout 超时时间（毫秒）\n * @param user\n * @param code\n * @return\n */\npublic static String doGet(String url, int timeout, String user, String code) {\n\ttry {\n\t\tCloseableHttpClient client = null;\n\n\t\t/* 相信自己的CA和所有自签名的证书 */\n\t\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t\t/* 不做证书校验 */\n\t\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\n\t\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\t\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t\t@Override\n\t\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\t\n\t\tclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\n\t\t//发送get请求\n\t\tHttpGet request = new HttpGet(url);\n\t\trequest.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\t\trequest.setHeader(\"User\", user);\n\t\trequest.setHeader(\"Code\", code);\n\t\tRequestConfig requestConfig = RequestConfig.custom()\n\t\t\t\t.setConnectTimeout(timeout)\n\t\t\t\t.setSocketTimeout(timeout).build();\n\t\trequest.setConfig(requestConfig);\n\t\tHttpResponse response = client.execute(request);\n\n\t\t/**读取服务器返回过来的json字符串数据**/\n\t\tString strResult = EntityUtils.toString(response.getEntity());\n\t\treturn strResult;\n\t}catch (Exception e) {\n\t\te.printStackTrace();\n\t}\n\treturn null;\n}\n```\npost请求\n```java\n/**\n * post请求（用于请求json格式的参数）\n * @param url 请求路径\n * @param params 请求参数\n * @param user 用户\n * @param code 秘钥\n * @return\n * @throws Exception\n */\npublic static String doPost(String url, String params, String user, String code) throws Exception {\n\n\tCloseableHttpClient httpclient = null;\n\n\t/* 相信自己的CA和所有自签名的证书 */\n\tSSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(new TrustSelfSignedStrategy()).build();\n\n\t/* 不做证书校验 */\n\tsslcontext.init(null, new TrustManager[] { truseAllManager }, null);\n\t\n\t/* 添加两个属性 new String[]{\"TLSv1.2\"} 和 null */\n\tSSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext,new String[]{\"TLSv1.2\"}, null, new HostnameVerifier() {\n\t\t@Override\n\t\tpublic boolean verify(String hostname, SSLSession session) {\n\t\t\treturn true;\n\t\t}\n\t});\n\n\thttpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();\n\tHttpPost httpPost = new HttpPost(url);// 创建httpPost\n\thttpPost.setHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n\thttpPost.setHeader(\"User\", user);\n\thttpPost.setHeader(\"Code\", code);\n\tString charSet = \"UTF-8\";\n\tStringEntity entity = new StringEntity(params, charSet);\n\thttpPost.setEntity(entity);\n\tCloseableHttpResponse response = null;\n\ttry {\n\n\t\tresponse = httpclient.execute(httpPost);\n\t\t\tHttpEntity responseEntity = response.getEntity();\n\t\t\tString jsonString = EntityUtils.toString(responseEntity);\n\t\t\treturn jsonString;\n\t}\n\tfinally {\n\t\tif (response != null) {\n\t\t\ttry {\n\t\t\t\tresponse.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\thttpclient.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n具体代码请到 github 自行[下载](https://github.com/charmsongo/ifctest)\n\n如果这里不能解决您的问题请参考如下链接\n\n[链接1](https://blog.csdn.net/taiyangdao/article/details/54707184)[链接2](https://blog.csdn.net/fsafs168/article/details/82020959)","tags":["JDK","https","证书"]},{"title":"Linux上用Jenkins执行shell","url":"/2018/10/20/Linux上用Jenkins执行shell/","content":"\n> 执行环境： Centos 7，jdk8\n\n# 安装Jenkins\n\nJenkins是个java程序所以需要先安装jdk\n\n## Jdk安装\n\n 1. 这里先在 winsdows 上下载 jdk-8u181-linux-x64.gz [连接](https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html)；\n![这里需要登录oracle才能下载](Linux上用Jenkins执行shell/1.png)\n 2. 然后通过winscp拖到linux上的 /usr/local 路径下；\n 3. 然后解压安装；\n```javascript\n[root@localhost /]# tar -xf jdk-8u121-linux-x64.tar.gz\n[root@localhost /]# mv jdk1.8.0_121/ /usr/local/jdk  && rm -rf jdk-8u121-linux-x64.tar.gz\n```\n 4. 再配置环境变量；\n```javascript\nroot@localhost:~# vim /etc/profile\nJAVA_HOME=/usr/local/jdk/\nPATH=$JAVA_HOME/bin:$PATH\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport JAVA_HOME PATH CLASSPATH \nroot@localhost:/usr/local# source /etc/profile\n```\n\n##  安装Jenkins\n\n```javascript\n[root@localhost ~]# wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war \n```\n\n## 打开防火墙\n需要注意的是，查看防火墙是否打开，打开的话需要放开端口9000或者直接关闭防火墙\n\n - 查看防火墙状态\n```javascript\n [root@localhost local]# firewall-cmd --state\nrunning \n```\n - 关闭防火墙\n```javascript\n[root@localhost local]#  systemctl stop firewalld\n```\n - 启动防火墙\n```javascript\n[root@localhost local]#  systemctl start firewalld\n```\n - 开放端口 9000\n```javascript\n[root@localhost local]# firewall-cmd --zone=public --add-port=9000/tcp --permanent  （--permanent永久生效，没有此参数重启后失效）\nsuccess\n```\n - 更新防火墙规则\n```javascript\n[root@localhost local]# firewall-cmd --reload\nsuccess \n```\n - 查看所有开放端口\n```javascript\n[root@localhost local]#  firewall-cmd --zone=public --list-ports\n9000/tcp    \n```\n## 自定义指定端口9000启动jenkins\n```javascript\n[root@localhost ~]# java -jar jenkins.war --httpPort=9000\n```\n## 浏览器登录\n\n地址栏输入 IP:9000 ，例：192.168.2.14：9000\n![在这里插入图片描述](Linux上用Jenkins执行shell/2.png)\n\n**根据提示信息找到初始密码输入登录**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/3.png)\n\n**默认选择 安装推荐插件**\n\n##  修改管理员密码\n上一步过后会有个创建一个管理员的页面，但是我这里不好使，所以就登陆admin，然后修改admin密码\n![在这里插入图片描述](Linux上用Jenkins执行shell/4.png)\n\n**拖到最下面修改密码**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/5.png)\n\n**然后可以注销后用修改的密码登陆了**\n\n##  创建一个执行shell的任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/6.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/7.png)\n\n**然后下一步拖到最下面选择构建下拉框选**\n\n![在这里插入图片描述](Linux上用Jenkins执行shell/8.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/9.png)\n\n## 构建刚创建的Jenkins任务\n![在这里插入图片描述](Linux上用Jenkins执行shell/10.png)\n\n\n## 查看执行结果\n![在这里插入图片描述](Linux上用Jenkins执行shell/11.png)\n![在这里插入图片描述](Linux上用Jenkins执行shell/12.png)\n\n**出现 Finished: SUCCESS 恭喜，即为执行成功**\n\n> 其它博客：\n> CSDN:https://blog.csdn.net/qq_29175301/article/details/83213252\n> OSChina:https://my.oschina.net/charmsongo/blog/2249904","tags":["linux","jenkins","shell"]},{"title":"对待金钱的思维","url":"/2018/10/12/对待金钱的思维/","content":"\n**穷人思维和富人思维**\n- 1.人越缺什么就会看重什么，越不缺什么就会看的越轻。\n- 2.穷人花钱买东西钱总是会先考虑自己还有多少钱，如果不够就不买了，如果买的话如何才能买到最实惠的东西，省钱思维；富人花钱买东西首先想到的是我想要什么，这个东西对我来说有什么用，是不是必须得，目标导向型。\n- 3.穷人思维考虑做一件事情的时候总是会忽略时间成本，喜欢用时间来换金钱，感觉多花些时间来少掏些金钱就是赚了。\n- 4.夫人思维花钱无外乎两件事情没意识为了赚钱，二是为了享受。\n- 5.减少无意义的频繁决策，节省宝贵的精力，用在有意义的事情上。\n- 6.开拓自己的视野，知道是一码事，做到是另一码事。"},{"title":"my blog's format has change","url":"/2018/10/07/my-blog-s-format-has-change/","content":"\n*你好啊*\n***\n我的博客的格式终于改变了，选择了一个 简约明朗 的样式，之后有时间我会同步更新\n技术博客。"},{"title":"你好,Hexo","url":"/2018/09/22/你好-Hexo/","content":"\n张博在床上躺着呢，\n哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈"}]